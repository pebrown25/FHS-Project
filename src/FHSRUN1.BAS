DECLARE SUB DataINIT (OPT$)
DECLARE SUB TableFREE (TNAME$)
DECLARE SUB TableLOAD (TNAME$, TNUM AS INTEGER, XL AS INTEGER)
DECLARE SUB ERRMessage (XEM$, XET%, XEL%)
DECLARE SUB ChnINIT (CHN() AS ANY, CHNBGN%, CHNMAX%)
DECLARE SUB ErrBEEP (XSND%)
DECLARE SUB FldRELEASE (FLDNUM%)
DECLARE SUB FmtFIND (FMTNAME$)
DECLARE SUB FmtFindFLD (FLDNAME$)
DECLARE SUB FmtGrpFREE (GNAME$)
DECLARE SUB FmtGrpLOAD (GNAME$, GNUM%)
DECLARE SUB FmtHREST ()
DECLARE SUB FmtRELEASE (Y%)
DECLARE SUB FmtUHOLD ()
DECLARE SUB GetFldPARMS ()
DECLARE SUB GetKEY ()
DECLARE SUB GetRESP ()
DECLARE SUB GetUFLD (OPT$)
DECLARE SUB MDFOpen (OPT$)
DECLARE SUB MSGExpand (ITXT$)
DECLARE SUB MSGFind (MSGID$, MNUM%)
DECLARE SUB MsgGrpFREE (GNAME$)
DECLARE SUB MsgGrpLOAD (GNAME$, GNUM%)
DECLARE SUB PutMSG (MSGTXT$)
DECLARE SUB SDFOpen (OPT$)
DECLARE SUB SetScrCOLOR ()
DECLARE FUNCTION SNX$ (A%)
DECLARE SUB TableKEY (OPT$, TP AS ANY, TDATA$())
DECLARE SUB TableSHOW (TP AS ANY, TDATA$(), TCHN() AS ANY)
DECLARE SUB TDFOpen (OPT$)
DECLARE SUB WinBDRY (C AS INTEGER, WNUM AS INTEGER)
DECLARE SUB WinCLOSE (OLVL%, NLVL%)
DECLARE SUB WinCLR ()
DECLARE SUB WinFORMAT (FMTNUM%)
DECLARE SUB WinOPEN (LOC$)
DECLARE SUB WinUPDATE ()
REM $INCLUDE: 'FHSCOMON.BAS'

REM $DYNAMIC
SUB ChnINIT (CHN() AS ChainPTRS, CHNBGN, CHNMAX)
    IF CHNMAX > CHNBGN THEN
       FOR X = CHNBGN TO CHNMAX
           CHN(X).FWD = X + 1: CHN(X).BWD = X - 1
       NEXT X
       CHN(CHNBGN).BWD = 0: CHN(CHNMAX).FWD = 0
    END IF
END SUB

SUB DataINIT (OPT$)
 ' Prepare to get DATA from FHSINIT.DAT
   CLOSE
   ON LOCAL ERROR GOTO INITErr
   OPEN "FHSINIT.DAT" FOR INPUT AS #5
   IF OPT$ = "INIT" THEN
      INPUT #5, IDataCNT: REDIM IDataNm$(IDataCNT), IDataBgn(IDataCNT)
      FOR X = 1 TO IDataCNT
          INPUT #5, X$, Z$
          IDataNm$(X) = RTRIM$(X$): IDataBgn(X) = VAL(Z$)
      NEXT X
      CLOSE #5
      OKAY = -1: GOTO INITEnd
   END IF
   X = IDataCNT: OKAY = 0
   WHILE (X > 0) AND (NOT OKAY)
      OKAY = (IDataNm$(X) = OPT$)
      IF NOT OKAY THEN X = X - 1
   WEND
   IF OKAY THEN
      SEEK #5, IDataBgn(X)
      ELSE
      SYSVAR.MVAR = OPT$
      CALL PutMSG("Unable to Locate DATA for [MVAR]...")
      CALL GetRESP
   END IF
   GOTO INITEnd

INITErr:
   PRINT "Error Processing File FHSINIT.DAT...ERR="; ERR; ", ERL="; ERL
   OKAY = 0
INITEnd:

END SUB

SUB DOSShell
800 ' Execute DOS Commands
    COLOR FG(1), BG(1): CLS
    CALL PutMSG("XXXXM075")
    LOCATE 1, 1: OKAY = -1
    ON LOCAL ERROR GOTO 850
    SHELL
    GOTO 890
850 ' Error with SHELL Command
    CALL ERRMessage("XXXXM076", ERR, ERL)
    OKAY = 0: RESUME 890
890 ' Return to Program
    CLS : CALL WinBDRY(0, 0): EXIT SUB

END SUB

REM $STATIC
SUB ErrBEEP (XSND)
    IF DUR > 0 THEN SOUND BP, DUR
END SUB

REM $DYNAMIC
SUB ERRMessage (XEM$, XET, XEL)
    X = EMCNT: FOUND = 0
    WHILE (X > 0) AND (NOT FOUND)
       FOUND = (XET = VAL(MID$(ERRMSG$(X), 1, 3)))
       IF NOT FOUND THEN X = X - 1
    WEND
    EMSG$ = MID$(ERRMSG$(X), 4, 255)
    SYSVAR.NVAR1 = XET: SYSVAR.NVAR2 = XEL
    CALL PutMSG(XEM$)
END SUB

REM $STATIC
SUB FldRELEASE (FLDNUM)
    Z = FLDNUM
    IF Z = 0 THEN Z = FMT.BGNFLD
    IF Z = 0 THEN EXIT SUB
    Z1 = FLDCHN(Z).BWD
FREEFLD:
    Z2 = FLDCHN(Z).FWD
    FFLD = FLDTAB(Z)
    DTXT$(Z) = ""
    IF FFLD.UTXT > 0 THEN
       IF UTXTFREE > 0 THEN UTXTCHN(UTXTFREE).BWD = FFLD.UTXT
       UTXTCHN(FFLD.UTXT).FWD = UTXTFREE
       UTXTCHN(FFLD.UTXT).BWD = 0
       UTXTFREE = FFLD.UTXT
       UTXT$(FFLD.UTXT) = "": HTXT$(FFLD.UTXT) = ""
       FFLD.UTXT = 0
       FMT.UFLDCT = FMT.UFLDCT - 1
    END IF
    FFLD.NAME = " ": FLDTAB(Z) = FFLD
    IF FldFREE > 0 THEN FLDCHN(FldFREE).BWD = Z
    FLDCHN(Z).FWD = FldFREE: FLDCHN(Z).BWD = 0
    FldFREE = Z
    FMT.FLDCT = FMT.FLDCT - 1
    IF Z = FMT.BGNFLD THEN FMT.BGNFLD = Z2
    IF (FLDNUM = 0) AND (Z2 > 0) THEN Z = Z2: GOTO FREEFLD
    IF Z1 > 0 THEN FLDCHN(Z1).FWD = Z2
    IF Z2 > 0 THEN FLDCHN(Z2).BWD = Z1
END SUB

REM $DYNAMIC
SUB FmtDREST
    ' Restore UTXT$() from DTXT$() - Restore updated data with default
    XFLD = FMT.BGNFLD
    WHILE XFLD > 0
      XTXT = FLDTAB(XFLD).UTXT
      IF ((FLDTAB(XFLD).CATR AND 17) > 0) THEN
         LSET UTXT$(XTXT) = DTXT$(XFLD)
         FLDTAB(XFLD).DO = 0
      END IF
      XFLD = FLDCHN(XFLD).FWD
    WEND
END SUB

SUB FmtFIND (FMTNAME$)
    FMTGP$ = MID$(FMTNAME$, 1, 4)
    X = 0: FOUND = 0
    WHILE (X < GRPMAX) AND (NOT FOUND)
       X = X + 1: FOUND = (SDFIndex(X).NAME = FMTGP$)
    WEND
    IF FOUND THEN
       CURFMT = SDFIndex(X).FIRST
       FOUND = 0
       WHILE (CURFMT > 0) AND (NOT FOUND)
          FOUND = (FMTTAB(CURFMT).NAME = FMTNAME$)
          IF NOT FOUND THEN CURFMT = FMTCHN(CURFMT).FWD
       WEND
    END IF
    IF NOT FOUND THEN
       SYSVAR.MVAR = FMTNAME$
       CALL PutMSG("XXXXM022")
       EXIT SUB
    END IF
    FMT = FMTTAB(CURFMT)
    IF ((FMT.TYPE AND 1) = 1) THEN WIN.WFMT = CURFMT
    IF ((FMT.TYPE AND 2) = 2) THEN WIN.DFMT = CURFMT
    IF ((FMT.TYPE AND 4) = 4) THEN WIN.OFMT = CURFMT
    IF ((FMT.TYPE AND 8) = 8) THEN WIN.MFMT = CURFMT
    IF ((FMT.TYPE AND 16) = 16) THEN WIN.TFMT = CURFMT
END SUB

SUB FmtFindFLD (FLDNAME$)
    FLD$ = "    ": LSET FLD$ = FLDNAME$
    FOUND = 0: XFLD = FMT.BGNFLD
    WHILE (XFLD > 0) AND (NOT FOUND)
      FOUND = (FLDTAB(XFLD).NAME = FLD$)
      IF NOT FOUND THEN XFLD = FLDCHN(XFLD).FWD
    WEND
    IF FOUND THEN WIN.CURFLD = XFLD: CALL GetFldPARMS
END SUB

REM $STATIC
SUB FmtGrpFREE (GNAME$)
    GNUM = 1: OKAY = -1
    IF GNAME$ = "ALL" THEN GOTO FGRPFREE
    GN$ = SPACE$(4): LSET GN$ = GNAME$
    FOUND = 0
    WHILE (GNUM < (GRPMAX + 1)) AND (NOT FOUND)
       FOUND = (SDFIndex(GNUM).NAME = GN$)
       IF NOT FOUND THEN GNUM = GNUM + 1
    WEND
FGRPFREE:
    IF GNUM > GRPMAX THEN EXIT SUB
    IF (SDFIndex(GNUM).OPEN) AND ((SDFIndex(GNUM).CHG AND 128) = 0) THEN
       IF (SDFIndex(GNUM).FIRST > 0) THEN
          Y = SDFIndex(GNUM).FIRST
          WHILE Y > 0
             X = FMTCHN(Y).FWD
             CALL FmtRELEASE(Y)
             Y = X
          WEND
          SDFIndex(GNUM).FIRST = 0
          SDFIndex(GNUM).LAST = 0
       END IF
       SDFIndex(GNUM).OPEN = 0
    END IF
    IF GNAME$ = "ALL" THEN GNUM = GNUM + 1: GOTO FGRPFREE
END SUB

SUB FmtGrpLOAD (GNAME$, GNUM)
    GN$ = SPACE$(4): LSET GN$ = GNAME$
    SYSVAR.FILENAME = CONFIG.SDF + "SFMTS.SDF"
    'LOADALL = ((GNAME$ = "ALL") OR ((GNAME$ = "INITIAL") AND ENV.LARGEMEM))
    LOADALL = (GNAME$ = "ALL")
    IF (GNAME$ = "ALL") OR (GNAME$ = "INITIAL") THEN GOTO FGRPINIT
    IF (CONFIG.SDF = ENV.SDF) THEN GOTO FGRPLKUP
    SDFCHANGE = -1
FGRPINIT:
    CALL SDFOpen("READ"): IF NOT OKAY THEN GOTO FGLEND
    FILEOPEN = -1
    FOR X = 1 TO GRPMAX
       SDFIndex(X).CHG = 0: SDFIndex(X).OPEN = 0: SDFIndex(X).FDIR = 0
       SDFIndex(X).BGNRBA = 0: SDFIndex(X).SIZE = 0
       SDFIndex(X).FIRST = 0: SDFIndex(X).LAST = 0
    NEXT X
    IF LOADALL THEN
       FMTMAX = SDFHdr.FMTCNT: FLDMAX = SDFHdr.FLDCNT
       UTXTMAX = SDFHdr.UFLDCNT
       ELSE
       FMTMAX = 0: FLDMAX = 0: UTXTMAX = 0
    END IF
    ON LOCAL ERROR GOTO FGLERR
    REDIM FMTTAB(FMTMAX) AS FmtENTRY, FMTCHN(FMTMAX) AS ChainPTRS
    CALL ChnINIT(FMTCHN(), 1, FMTMAX)
    FmtFREE = -(FMTMAX > 0)
    REDIM FLDTAB(FLDMAX) AS FldENTRY, FLDCHN(FLDMAX) AS ChainPTRS, DTXT$(FLDMAX)
    CALL ChnINIT(FLDCHN(), 1, FLDMAX)
    FldFREE = -(FLDMAX > 0)
    REDIM UTXT$(UTXTMAX), UTXTCHN(UTXTMAX) AS ChainPTRS, HTXT$(UTXTMAX)
    CALL ChnINIT(UTXTCHN(), 1, UTXTMAX)
    UTXTFREE = -(UTXTMAX > 0)
    SEEK #1, LEN(SDFHdr) + 1
    FOR X = 1 TO SDFHdr.GRPCNT
        FDIR = SEEK(1)
        GET #1, , SDFGrpDIR
        Y = 0: FOUND = 0
        WHILE (Y < GRPMAX) AND (NOT FOUND)
           Y = Y + 1
           FOUND = (SDFGrpDIR.NAME = SDFIndex(Y).NAME)
        WEND
        IF FOUND THEN
           SDFIndex(Y).FDIR = FDIR
           SDFIndex(Y).CHG = SDFGrpDIR.CHG
           SDFIndex(Y).SIZE = SDFGrpDIR.FMTCNT
           SDFIndex(Y).BGNRBA = SDFGrpDIR.FIRST
           SDFIndex(Y).FIRST = 0
           SDFIndex(Y).LAST = 0
        END IF
    NEXT X
    ENV.SDF = CONFIG.SDF
    IF LOADALL THEN GN = 1: GOTO FGRPLOAD
CHGFGRPS:
    CN = 0
CHGFGNXT:
    CN = CN + 1
    SELECT CASE CN
       CASE 1: LSET GN$ = "XXXX": GOTO FGRPLKUP
       CASE 2: LSET GN$ = MID$(ENV.PGMNAME, 4, 4): GOTO FGRPLKUP
    END SELECT
    IF GNAME$ = "INITIAL" THEN GOTO FGLEND
    LSET GN$ = GNAME$: SDFCHANGE = 0
FGRPLKUP:
    GN = 0: OKAY = 0
    FOUND = 0
    WHILE (GN < GRPMAX) AND (NOT FOUND)
       GN = GN + 1: FOUND = (SDFIndex(GN).NAME = GN$)
    WEND
    IF NOT FOUND THEN
       SYSVAR.MVAR = GN$
       CALL PutMSG("XXXXM023")
       GOTO FGRPNEXT
    END IF
    IF GNAME$ <> "INITIAL" THEN GNUM = GN
FGRPLOAD:
    ON LOCAL ERROR GOTO FGLERR
    OKAY = -1
    IF GN > GRPMAX THEN GOTO FGLEND
    LSET GN$ = SDFIndex(GN).NAME
    IF SDFIndex(GN).OPEN OR (SDFIndex(GN).BGNRBA = 0) THEN GOTO FGRPNEXT
    IF NOT FILEOPEN THEN
       CALL SDFOpen("READ")
       IF NOT OKAY THEN GOTO FGLEND
       FILEOPEN = -1
    END IF
    GET #1, SDFIndex(GN).FDIR, SDFGrpDIR
    SEEK #1, SDFGrpDIR.FIRST
    X = SDFGrpDIR.FMTCNT: X1 = 0:
    W = SDFGrpDIR.FLDCNT
    Z = SDFGrpDIR.UFLDCNT
    WHILE X > 0
       IF FmtFREE = 0 THEN
          FmtFREE = FMTMAX + 1
          FMTMAX = FMTMAX + X
          REDIM PRESERVE FMTTAB(FMTMAX) AS FmtENTRY, FMTCHN(FMTMAX) AS ChainPTRS
          CALL ChnINIT(FMTCHN(), FmtFREE, FMTMAX)
          IF X1 > 0 THEN FMTCHN(X1).FWD = FmtFREE
       END IF
       IF X1 = 0 THEN
          SDFIndex(GN).FIRST = FmtFREE: FMTCHN(FmtFREE).BWD = -GN
          ELSE
          FMTCHN(FmtFREE).BWD = X1
       END IF
       X1 = FmtFREE: FmtFREE = FMTCHN(X1).FWD
       GET #1, , SDFFmtREC
       FMT.NAME = SDFFmtREC.NAME
       FMT.FLDCT = SDFFmtREC.FLDCNT
       FMT.BGNFLD = 0: FMT.UFLDCT = 0
       FMT.WIN = SDFFmtREC.WINNUM: FMT.COLOR = SDFFmtREC.WinBGColor
       FMT.TYPE = SDFFmtREC.TYPE
       Y = FMT.FLDCT: Y1 = 0
       WHILE Y > 0
          IF FldFREE = 0 THEN
             FldFREE = FLDMAX + 1: IF W = 0 THEN W = 1
             FLDMAX = FLDMAX + W
             REDIM PRESERVE FLDTAB(FLDMAX) AS FldENTRY, FLDCHN(FLDMAX) AS ChainPTRS
             REDIM PRESERVE DTXT$(FLDMAX)
             CALL ChnINIT(FLDCHN(), FldFREE, FLDMAX)
             IF Y1 > 0 THEN FLDCHN(Y1).FWD = FldFREE
          END IF
          W = W - 1
          IF Y1 = 0 THEN
             FLDCHN(FldFREE).BWD = -GN: FMT.BGNFLD = FldFREE
             ELSE
             FLDCHN(FldFREE).BWD = Y1
          END IF
          Y1 = FldFREE: FldFREE = FLDCHN(Y1).FWD
          GET #1, , SDFFldRec
          FFLD.NAME = SDFFldRec.NAME
          FFLD.CATR = 256 * ASC(SDFFldRec.COLOR) + ASC(SDFFldRec.ATR)
          FFLD.LLCC = 256 * ASC(SDFFldRec.LL) + ASC(SDFFldRec.CC)
          FFLD.FLDL = 256 * ASC(SDFFldRec.FL) + ASC(SDFFldRec.DL)
          DTXT$(Y1) = SPACE$(ASC(SDFFldRec.LTH))
          GET #1, , DTXT$(Y1)
          IF ((FFLD.CATR AND 17) > 0) THEN
             FMT.UFLDCT = FMT.UFLDCT + 1
             IF UTXTFREE = 0 THEN
                UTXTFREE = UTXTMAX + 1: IF Z = 0 THEN Z = 1
                UTXTMAX = UTXTMAX + Z
                REDIM PRESERVE UTXT$(UTXTMAX), HTXT$(UTXTMAX)
                REDIM PRESERVE UTXTCHN(UTXTMAX) AS ChainPTRS
                CALL ChnINIT(UTXTCHN(), UTXTFREE, UTXTMAX)
             END IF
             Z = Z - 1
             FFLD.UTXT = UTXTFREE
             UTXTFREE = UTXTCHN(FFLD.UTXT).FWD
             IF (NOT ENV.LARGEMEM) OR (GN$ = "XXXX") THEN
                UTXT$(FFLD.UTXT) = SPACE$(ASC(SDFFldRec.FL))
                LSET UTXT$(FFLD.UTXT) = DTXT$(Y1)
                HTXT$(FFLD.UTXT) = UTXT$(FFLD.UTXT)
             END IF
             ELSE
             FFLD.UTXT = 0
          END IF
          FLDTAB(Y1) = FFLD
          Y = Y - 1
       WEND
       IF FldFREE > 0 THEN FLDCHN(FldFREE).BWD = 0
       IF Y1 > 0 THEN FLDCHN(Y1).FWD = 0
       FMTTAB(X1) = FMT
       X = X - 1
    WEND
    SDFIndex(GN).LAST = X1
    IF FmtFREE > 0 THEN FMTCHN(FmtFREE).BWD = 0
    IF X1 > 0 THEN FMTCHN(X1).FWD = 0
    SDFIndex(GN).OPEN = -1
FGRPNEXT:
    IF LOADALL THEN GN = GN + 1: GOTO FGRPLOAD
    IF GNAME$ = "INITIAL" THEN GOTO CHGFGNXT
    IF MDFCHANGE THEN GOTO CHGFGNXT
    GOTO FGLEND
FGLERR:
    SYSVAR.MVAR = GN$: SYSVAR.NVAR1 = ERR: SYSVAR.NVAR2 = ERL
    CALL PutMSG("XXXXM077")
    OKAY = 0: RESUME FGLFREE
FGLFREE:
    CALL FmtGrpFREE(GN$)
FGLEND:
    ON LOCAL ERROR GOTO FGLERR2
    IF FILEOPEN THEN CLOSE #1
    GOTO FGLEXIT
FGLERR2:
    RESUME FGLEXIT
FGLEXIT:
    ON LOCAL ERROR GOTO 0
END SUB

REM $DYNAMIC
SUB FmtHREST
    ' Restore UTXT$() from HTXT$() - Restore Updated data with Held data
    XFLD = FMT.BGNFLD
    WHILE XFLD > 0
      XTXT = FLDTAB(XFLD).UTXT
      IF (FLDTAB(XFLD).CATR AND 17) > 0 THEN
         LSET UTXT$(XTXT) = HTXT$(XTXT): FLDTAB(XFLD).DO = 0
      END IF
      XFLD = FLDCHN(XFLD).FWD
    WEND
END SUB

REM $STATIC
SUB FmtRELEASE (Y)
    FMT = FMTTAB(Y)
    Y1 = FMTCHN(Y).BWD: Y2 = FMTCHN(Y).FWD
    CALL FldRELEASE(0)
    FMT.NAME = ""
    FMTTAB(Y) = FMT
    IF Y1 > 0 THEN FMTCHN(Y1).FWD = Y2
    IF Y2 > 0 THEN FMTCHN(Y2).BWD = Y1
    IF FmtFREE > 0 THEN FMTCHN(FmtFREE).BWD = Y
    FMTCHN(Y).FWD = FmtFREE: FMTCHN(Y).BWD = 0
    FmtFREE = Y
END SUB

REM $DYNAMIC
SUB FmtUHOLD
    ' Store UTXT$() into HTXT$() - save updatable fields
    XFLD = FMT.BGNFLD
    WHILE XFLD > 0
      XTXT = FLDTAB(XFLD).UTXT
      IF (FLDTAB(XFLD).CATR AND 17) > 0 THEN LSET HTXT$(XTXT) = UTXT$(XTXT)
      XFLD = FLDCHN(XFLD).FWD
    WEND
END SUB

SUB GetFldPARMS
    IF WIN.CURFLD = 0 THEN FATR = 0: EXIT SUB
    FFLD = FLDTAB(WIN.CURFLD)
    FLIN = (FFLD.LLCC \ 256) + WIN.ULR
    BCOL = (FFLD.LLCC AND 255)
    DL = (FFLD.FLDL AND 255): FL = FFLD.FLDL \ 256
    IF DL = 0 THEN DL = FL: FFLD.FLDL = FL * 256 + DL
    IF BCOL = 0 THEN
       IF FFLD.UTXT <> 0 THEN
          DL = LEN(UTXT$(FFLD.UTXT))
          IF DL > 0 THEN FFLD.FLDL = FL * 256 + DL
       END IF
       BCOL = (WIN.LRC - WIN.ULC - DL) / 2
       IF BCOL < 0 THEN BCOL = 1: DL = WIN.LRC - WIN.ULC - 1
    END IF
    BCOL = WIN.ULC + BCOL
    ECOL = BCOL + DL - 1
    FCOLOR = FFLD.CATR \ 256
    IF FCOLOR = 0 THEN
       FCOLOR = FMT.COLOR
       IF FCOLOR = 0 THEN
          FCOLOR = WIN.BGCOLOR
          IF FCOLOR = 0 THEN FCOLOR = 1
       END IF
    END IF
    FATR = (FFLD.CATR AND 255)
    COLOR FG(FCOLOR), BG(FCOLOR)
    IF (FLIN < 26) AND (BCOL) < 81 THEN LOCATE FLIN, BCOL, 0
END SUB

REM $STATIC
SUB GetKEY
GNKEY:
    A$ = ""
    WHILE A$ = "": A$ = INKEY$: WEND
    A = ASC(RIGHT$(A$, 1))
    'IF (LEN(A$) = 2 AND A = 50) THEN
    '   ENV.SHOWMSGID = NOT ENV.SHOWMSGID
    '   IF ENV.SHOWMSGID AND (SYSVAR.MSGNAME <> SPACE$(8)) THEN
    '      LOCATE 25, 1, 0: COLOR FG(5), BG(5): PRINT SYSVAR.MSGNAME;
    '   END IF
    '   GOTO GNKEY
    'END IF
END SUB

SUB GetRESP
    A$ = UCASE$(INPUT$(1)): A = ASC(A$)
END SUB

REM $DYNAMIC
SUB GetUFLD (OPT$)
    ' AT Entry: CURFMT, FMT, WIN.CLIN, WIN.CCOL must be established
    ' At Exit:  FOUND, WIN.CURFLD, FFLD, FLDPARMS
    FOUND = 0
    SELECT CASE OPT$
       CASE "THIS": GOTO GETTHIS
       CASE "FIRST": GOTO GETFIRST
       CASE "NEXT": GOTO GETNEXT
       CASE "PREV": GOTO GETPREV
       CASE "LAST": GOTO GETLAST
    END SELECT
    EXIT SUB
GETTHIS:
   ' At END, WIN.CURFLD = Nearest UFLD with FLIN,BCOL "to left of" WIN.CLIN,WIN.CCOL
    XFLD = FMT.BGNFLD
    FOUND = 0: WIN.CURFLD = 0
    WHILE (XFLD > 0) AND (NOT FOUND)
       FFLD = FLDTAB(XFLD)
       FOUND = ((FFLD.CATR AND 1) = 1)
       IF FOUND THEN
          LL = (FFLD.LLCC \ 256) + WIN.ULR
          CC = (FFLD.LLCC AND 255) + WIN.ULC
          FOUND = (LL <= WIN.CLIN)
          IF FOUND THEN
             FOUND = (WIN.CLIN = LL)
             IF (NOT FOUND) OR (FOUND AND (CC <= WIN.CCOL)) THEN WIN.CURFLD = XFLD
             FOUND = (FOUND AND ((CC <= WIN.CCOL) AND (WIN.CCOL < CC + (FFLD.FLDL AND 255))))
          END IF
       END IF
       IF NOT FOUND THEN XFLD = FLDCHN(XFLD).FWD
       IF LL > WIN.CLIN THEN XFLD = 0
    WEND
    IF WIN.CURFLD > 0 THEN GOTO GETPARMS
    EXIT SUB
GETFIRST:
    WIN.CURFLD = FMT.BGNFLD
    WHILE (WIN.CURFLD > 0) AND (NOT FOUND)
       FOUND = ((FLDTAB(WIN.CURFLD).CATR AND 1) > 0)
       IF NOT FOUND THEN WIN.CURFLD = FLDCHN(WIN.CURFLD).FWD
    WEND
    IF WIN.CURFLD > 0 THEN GOTO GETPARMS
    EXIT SUB
GETNEXT:
    IF WIN.CURFLD = 0 THEN GOTO GETFIRST
    XFLD = WIN.CURFLD
    WHILE (XFLD > 0) AND (NOT FOUND)
       XFLD = FLDCHN(XFLD).FWD
       IF XFLD > 0 THEN FOUND = ((FLDTAB(XFLD).CATR AND 1) > 0)
    WEND
    IF NOT FOUND THEN GOTO GETFIRST
    WIN.CURFLD = XFLD
    GOTO GETPARMS
GETPREV:
    IF WIN.CURFLD = 0 THEN GOTO GETLAST
    XFLD = WIN.CURFLD
    WHILE (XFLD > 0) AND (NOT FOUND)
       XFLD = FLDCHN(XFLD).BWD
       IF XFLD > 0 THEN FOUND = ((FLDTAB(XFLD).CATR AND 1) > 0)
    WEND
    IF NOT FOUND THEN GOTO GETLAST
    WIN.CURFLD = XFLD
    GOTO GETPARMS
GETLAST:
    XFLD = FMT.BGNFLD: WIN.CURFLD = 0
    WHILE (XFLD > 0)
       FOUND = ((FLDTAB(XFLD).CATR AND 1) > 0)
       IF FOUND THEN WIN.CURFLD = XFLD: FOUND = 0
       XFLD = FLDCHN(XFLD).FWD
    WEND
    FOUND = (WIN.CURFLD > 0)
    IF FOUND THEN GOTO GETPARMS
    EXIT SUB
GETPARMS:
    CALL GetFldPARMS
    EXIT SUB
END SUB

REM $STATIC
SUB MDFOpen (OPT$)
    OKAY = 0
    LSET SYSVAR.FILENAME = CONFIG.MDF + "MSGS.MDF"
    ON LOCAL ERROR GOTO NOMDF
CHKMDF:
    OPEN SYSVAR.FILENAME FOR INPUT AS #1
    CLOSE #1
    IF OPT$ = "NEW" THEN
       CALL PutMSG("XXXXM002")
       IF A$ <> SNGLKEY$(1) THEN GOTO MDFOpenEND
       KILL SYSVAR.FILENAME
       GOTO NEWMDF
    END IF
    GOTO OLDMDF
NOMDF:
    X = ERR
    CLOSE
    IF OPT$ = "NEW" THEN RESUME NEWMDF
    CALL ERRMessage("XXXXM030", X, 0)
    IF A = 27 THEN RESUME MDFOpenEND
    RESUME CHKMDF
OLDMDF:
    ON LOCAL ERROR GOTO MDFOpenERR
    SELECT CASE OPT$
       CASE "READ": OPEN SYSVAR.FILENAME FOR BINARY ACCESS READ AS #1
       CASE "WRITE": OPEN SYSVAR.FILENAME FOR BINARY ACCESS READ WRITE AS #1
       CASE ELSE: GOTO MDFOpenEND
    END SELECT
    GET #1, , MDFHdr
    LSET SYSVAR.MVAR = "MDF"
    IF MDFHdr.FTYPE <> "MDF" THEN
       CALL PutMSG("XXXXM033")
       GOTO MDFOpenEND
    END IF
    IF MDFHdr.VER <> CHR$(0) THEN
       CALL PutMSG("XXXXM036")
       IF A$ <> SNGLKEY$(1) THEN GOTO MDFOpenEND
    END IF
    OKAY = -1
    GOTO MDFOpenEND
NEWMDF:
    ON LOCAL ERROR GOTO MDFOpenERR
    OPEN SYSVAR.FILENAME FOR BINARY ACCESS READ WRITE AS #1
    OKAY = -1
    GOTO MDFOpenEND
MDFOpenERR:
    CALL ERRMessage("XXXXM030", ERR, ERL)
    RESUME MDFOpenEND
MDFOpenEND:
    IF NOT OKAY THEN CLOSE  ELSE ENV.MDF = CONFIG.MDF
    ON LOCAL ERROR GOTO 0
END SUB

SUB MSGExpand (ITXT$)
   OTXT$ = SPACE$(255): VDEPTH = 0
EXPTEXT:
   VCNT = 0: LSET OTXT$ = " "
   X1 = 1: Z1 = 1: ML = LEN(RTRIM$(ITXT$))
NXTMVAR:
   Y1 = INSTR(X1, ITXT$, "["): IF Y1 = 0 THEN GOTO LASTMSEG
   Y2 = INSTR(Y1, ITXT$, "]"): IF Y2 = 0 THEN GOTO LASTMSEG
   MID$(OTXT$, Z1, Y1 - X1) = MID$(ITXT$, X1, Y1 - X1)
   Z1 = Z1 + Y1 - X1: X1 = Y2 + 1: VCNT = VCNT + 1
   MVAR$ = MID$(ITXT$, Y1 + 1, Y2 - Y1 - 1)
   SELECT CASE MVAR$
      CASE "MVAR": MVAL$ = RTRIM$(SYSVAR.MVAR)
      CASE "NVAR1": MVAL$ = LTRIM$(STR$(SYSVAR.NVAR1))
      CASE "NVAR2": MVAL$ = LTRIM$(STR$(SYSVAR.NVAR2))
      CASE "NVAR3": MVAL$ = LTRIM$(STR$(SYSVAR.NVAR3))
      CASE "PAGE": MVAL$ = LTRIM$(STR$(PAGE.COUNT))
      CASE "LINE": MVAL$ = LTRIM$(STR$(PAGE.LINE))
      CASE "TIME": MVAL$ = TIME$
      CASE "FAMFILE": MVAL$ = RTRIM$(LEFT$(FSETUP$(ENV.FSETUP), 8))
      CASE "FILENAME": MVAL$ = RTRIM$(SYSVAR.FILENAME)
      CASE "PGMNAME": MVAL$ = RTRIM$(SYSVAR.PGMNAME)
      CASE "RPTNAME": MVAL$ = RTRIM$(RDFReport.NAME)
      CASE "TABNAME": MVAL$ = RTRIM$(SYSVAR.TABNAME)
      CASE "CHARTID": MVAL$ = RTRIM$(SYSVAR.CHARTID)
      CASE "SUBJECT": MVAL$ = RTRIM$(SYSVAR.SUBJECT)
      CASE "DATE": MVAL$ = SYSVAR.DATE
      CASE "PSFX": MVAL$ = ENV.PGMSFX
      CASE "EMSG": MVAL$ = EMSG$
      CASE ELSE: GOTO NOVAR
   END SELECT
   GOTO MOVESEG:
NOVAR:
   MVAL$ = MID$(ITXT$, Y1, Y2 - Y1 + 1): VCNT = VCNT - 1
MOVESEG:
   MID$(OTXT$, Z1, LEN(MVAL$)) = MVAL$
   Z1 = Z1 + LEN(MVAL$)
   GOTO NXTMVAR
LASTMSEG:
   LS = ML - X1 + 1
   IF LS > 0 THEN MID$(OTXT$, Z1, LS) = MID$(ITXT$, X1, LS)
   LSET ITXT$ = OTXT$: VDEPTH = VDEPTH + 1
   IF (VCNT > 0) AND (VDEPTH < 5) THEN GOTO EXPTEXT
END SUB

SUB MSGFind (MSGID$, MNUM)
   ZPFX$ = LEFT$(MSGID$, 4)
   MNUM = 0: FOUND = 0: ZGRP = 0
   WHILE (ZGRP < GRPMAX) AND (NOT FOUND)
      ZGRP = ZGRP + 1
      FOUND = (ZPFX$ = MDFIndex(ZGRP).NAME)
   WEND
   IF NOT FOUND THEN EXIT SUB
   ZSFX$ = "    ": LSET ZSFX$ = MID$(MSGID$, 5, 4)
   MNUM = MDFIndex(ZGRP).FIRST: FOUND = 0
   WHILE (MNUM > 0) AND (NOT FOUND)
      FOUND = (ZSFX$ = LEFT$(MSGDATA$(MNUM), 4))
      IF NOT FOUND THEN MNUM = MSGDATACHN(MNUM).FWD
   WEND
   IF FOUND THEN SYSVAR.MSGNAME = MSGID$
END SUB

SUB MsgFORMAT
    IF WIN.MFMT > 0 THEN
       OLVL = ENV.WINLVL
       CURFMT = WIN.MFMT
       FMT = FMTTAB(CURFMT)
       IF FMT.UFLDCT > 0 THEN CALL FmtUHOLD
       CALL WinOPEN("MSG")
       CALL WinFORMAT(0)
       IF FMT.UFLDCT > 0 THEN
          CALL WinUPDATE
          IF A = 27 THEN CALL FmtHREST
          CALL PutMSG("")
       END IF
       CALL WinCLOSE(0, OLVL)
    END IF
END SUB

SUB MsgGrpFREE (GNAME$)
    GNUM = 1: OKAY = -1
    IF GNAME$ = "ALL" THEN GOTO MGRPFREE
    GN$ = SPACE$(4): LSET GN$ = GNAME$
    FOUND = 0
    WHILE (GNUM < (GRPMAX + 1)) AND (NOT FOUND)
       FOUND = (MDFIndex(GNUM).NAME = GN$)
       IF NOT FOUND THEN GNUM = GNUM + 1
    WEND
MGRPFREE:
    IF GNUM > GRPMAX THEN EXIT SUB
    IF (MDFIndex(GNUM).OPEN) THEN
       IF (MDFIndex(GNUM).FIRST > 0) THEN
          X = MSGDATAFREE
          Y = MDFIndex(GNUM).LAST: MDFIndex(GNUM).LAST = 0
          IF X > 0 THEN MSGDATACHN(X).BWD = Y
          IF Y > 0 THEN MSGDATACHN(Y).FWD = X
          WHILE Y > 0
             MSGDATA$(Y) = ""
             Y = MSGDATACHN(Y).BWD
          WEND
          X = MDFIndex(GNUM).FIRST
          MDFIndex(GNUM).FIRST = 0
          MSGDATACHN(X).BWD = 0
          MSGDATAFREE = X
       END IF
       MDFIndex(GNUM).OPEN = 0
    END IF
    IF GNAME$ = "ALL" THEN GNUM = GNUM + 1: GOTO MGRPFREE
END SUB

SUB MsgGrpLOAD (GNAME$, GNUM)
    ON LOCAL ERROR GOTO MGLERR
    GN$ = SPACE$(4): LSET GN$ = GNAME$
    SYSVAR.FILENAME = CONFIG.MDF + "MSGS.MDF"
    IF (GNAME$ = "ALL") OR (GNAME$ = "INITIAL") THEN GOTO MGRPINIT
    IF (CONFIG.MDF = ENV.MDF) THEN GOTO MGRPLKUP
    MDFCHANGE = -1
MGRPINIT:
    LOADALL = ((GNAME$ = "ALL") OR ((GNAME$ = "INITIAL") AND ENV.LARGEMEM))
    CALL MDFOpen("READ"): IF NOT OKAY THEN GOTO MGLEND
    FILEOPEN = -1
    FOR X = 1 TO GRPMAX
       MDFIndex(X).CHG = 0: MDFIndex(X).OPEN = 0: MDFIndex(X).FDIR = 0
       MDFIndex(X).BGNRBA = 0: MDFIndex(X).SIZE = 0
       MDFIndex(X).FIRST = 0: MDFIndex(X).LAST = 0
    NEXT X
    IF LOADALL THEN MSGMAX = MDFHdr.MSGCNT ELSE MSGMAX = 0
    REDIM MSGDATA$(MSGMAX), MSGDATACHN(MSGMAX) AS ChainPTRS
    CALL ChnINIT(MSGDATACHN(), 1, MSGMAX)
    MSGDATAFREE = -(MSGMAX > 0)
    SEEK #1, LEN(MDFHdr) + 1
    FOR X = 1 TO MDFHdr.GRPCNT
        FDIR = SEEK(1)
        GET #1, , MDFGrpDIR
        Y = 0: FOUND = 0
        WHILE (Y < GRPMAX) AND (NOT FOUND)
           Y = Y + 1
           FOUND = (MDFGrpDIR.NAME = MDFIndex(Y).NAME)
        WEND
        IF FOUND THEN
           MDFIndex(Y).FDIR = FDIR
           MDFIndex(Y).CHG = MDFGrpDIR.CHG
           MDFIndex(Y).SIZE = MDFGrpDIR.MSGCNT
           MDFIndex(Y).BGNRBA = MDFGrpDIR.FIRST
           MDFIndex(Y).FIRST = 0
           MDFIndex(Y).LAST = 0
        END IF
    NEXT X
    ENV.MDF = CONFIG.MDF
    IF LOADALL THEN GN = 1: GOTO MGRPLOAD
CHGMGRPS:
    CN = 0
CHGMGNXT:
    CN = CN + 1
    SELECT CASE CN
       CASE 1: LSET GN$ = "XXXX": GOTO MGRPLKUP
       CASE 2: LSET GN$ = MID$(ENV.PGMNAME, 4, 4): GOTO MGRPLKUP
    END SELECT
    IF GNAME$ = "INITIAL" THEN GOTO MGLEND
    LSET GN$ = GNAME$: MDFCHANGE = 0
MGRPLKUP:
    GN = 0: OKAY = 0
    FOUND = 0
    WHILE (GN < GRPMAX) AND (NOT FOUND)
       GN = GN + 1: FOUND = (MDFIndex(GN).NAME = GN$)
    WEND
    IF NOT FOUND THEN
       SYSVAR.MVAR = GN$
       CALL PutMSG("XXXXM024")
       GOTO MGRPNEXT
    END IF
    IF GNAME$ <> "INITIAL" THEN GNUM = GN
MGRPLOAD:
    OKAY = -1
    IF GN > GRPMAX THEN GOTO MGLEND
    IF MDFIndex(GN).OPEN OR (MDFIndex(GN).BGNRBA = 0) THEN GOTO MGRPNEXT
    IF NOT FILEOPEN THEN
       CALL MDFOpen("READ")
       IF NOT OKAY THEN GOTO MGLEND
       FILEOPEN = -1
    END IF
    GET #1, MDFIndex(GN).FDIR, MDFGrpDIR
    SEEK #1, MDFGrpDIR.FIRST
    X = MDFGrpDIR.MSGCNT: X1 = 0
    L$ = " "
    WHILE (X > 0)
       IF MSGDATAFREE = 0 THEN
          MSGDATAFREE = MSGMAX + 1
          MSGMAX = MSGMAX + X
          REDIM PRESERVE MSGDATA$(MSGMAX), MSGDATACHN(MSGMAX) AS ChainPTRS
          CALL ChnINIT(MSGDATACHN(), MSGDATAFREE, MSGMAX)
          IF X1 > 0 THEN MSGDATACHN(X1).FWD = MSGDATAFREE
       END IF
       IF X1 = 0 THEN
          MDFIndex(GN).FIRST = MSGDATAFREE
          MSGDATACHN(MSGDATAFREE).BWD = -GN
          ELSE
          MSGDATACHN(MSGDATAFREE).BWD = X1
       END IF
       X1 = MSGDATAFREE: MSGDATAFREE = MSGDATACHN(MSGDATAFREE).FWD
       GET #1, , L$
       MSGDATA$(X1) = SPACE$(ASC(L$))
       GET #1, , MSGDATA$(X1)
       X = X - 1
    WEND
    MDFIndex(GN).LAST = X1
    IF MSGDATAFREE > 0 THEN MSGDATACHN(MSGDATAFREE).BWD = 0
    IF X1 > 0 THEN MSGDATACHN(X1).FWD = 0
    MDFIndex(GN).OPEN = -1
MGRPNEXT:
    IF LOADALL THEN GN = GN + 1: GOTO MGRPLOAD
    IF GNAME$ = "INITIAL" THEN GOTO CHGMGNXT
    IF MDFCHANGE THEN GOTO CHGMGNXT
    GOTO MGLEND
MGLERR:
    SYSVAR.MVAR = GN$: SYSVAR.NVAR1 = ERR: SYSVAR.NVAR2 = ERL
    CALL PutMSG("XXXXM078")
    OKAY = 0: RESUME MGLFREE
MGLFREE:
    CALL MsgGrpFREE(GN$)
MGLEND:
    CLOSE
END SUB

SUB OptDISPLAY (F AS INTEGER)
    IF F > 0 THEN OFMT = F: WIN.OFMT = F:  ELSE OFMT = WIN.OFMT
    IF OFMT > 0 THEN
       COLOR FG(WIN.BGCOLOR), BG(WIN.BGCOLOR)
       LOCATE WIN.LRR - 1, WIN.ULC + 1, 0
       PRINT TAB(WIN.LRC);
       Z = FMTTAB(OFMT).BGNFLD
       LL = WIN.LRR - WIN.ULR - 1
       WHILE Z > 0
          CC = (FLDTAB(Z).LLCC AND 255)
          FLDTAB(Z).LLCC = 256 * LL + CC
          Z = FLDCHN(Z).FWD
       WEND
       CALL WinFORMAT(OFMT)
    END IF
END SUB

SUB OPTHilite (XNAME$, XTXT$, XCOLOR)
    IF WIN.OFMT > 0 THEN
       FMT = FMTTAB(WIN.OFMT)
       CALL FmtFindFLD(XNAME$): IF NOT FOUND THEN EXIT SUB
       COLOR FG(XCOLOR), BG(XCOLOR)
       IF XTXT$ <> "" THEN
          PRINT XTXT$;
       ELSEIF (FFLD.UTXT > 0) THEN
          PRINT MID$(UTXT$(FFLD.UTXT), FFLD.DO + 1, FFLD.FLDL AND 255);
          ELSE
          PRINT DTXT$(WIN.CURFLD);
       END IF
   END IF
END SUB

SUB PgmPREP (PNAME$)
   OKAY = 0: LSET SYSVAR.PGMNAME = PNAME$
   PN$ = RTRIM$(PNAME$) + ENV.PGMSFX
   OGRP$ = MID$(ENV.PGMNAME, 4, 4)
   PGRP$ = MID$(SYSVAR.PGMNAME, 4, 4)
   XGRP = 0: FOUND = 0
   WHILE (XGRP < GRPMAX) AND (NOT FOUND)
      XGRP = XGRP + 1
      FOUND = (PGRP$ = MDFIndex(XGRP).NAME)
   WEND
   IF NOT FOUND THEN
      CALL PutMSG("XXXXM025")
      EXIT SUB
   END IF
PGMCHK:
   ON LOCAL ERROR GOTO PGMDISK
   OPEN PN$ FOR INPUT AS #1
   CLOSE
   ON LOCAL ERROR GOTO 0
   GOTO PGMFREE
PGMDISK:
   CLOSE
   CALL PutMSG("XXXXM001")
   IF A = 27 THEN RESUME PGMEND
   RESUME PGMCHK
PGMFREE:
   IF NOT ENV.LARGEMEM THEN GOTO PGMMSGS
   OKAY = -1: IF OGRP$ = "    " THEN GOTO PGMUFLDS
   OGRP = 0: FOUND = 0
   WHILE (OGRP < GRPMAX) AND (NOT FOUND)
      OGRP = OGRP + 1
      FOUND = (OGRP$ = SDFIndex(OGRP).NAME)
   WEND
   IF NOT FOUND THEN GOTO PGMUFLDS
   Y = SDFIndex(OGRP).FIRST
   WHILE Y > 0
      Z = FMTTAB(Y).BGNFLD
      WHILE Z > 0
         ZZ = FLDTAB(Z).UTXT
         IF ZZ > 0 THEN UTXT$(ZZ) = "": HTXT$(ZZ) = ""
         Z = FLDCHN(Z).FWD
      WEND
      Y = FMTCHN(Y).FWD
   WEND
PGMUFLDS:
   Y = SDFIndex(XGRP).FIRST
   WHILE Y > 0
      Z = FMTTAB(Y).BGNFLD
      WHILE Z > 0
         FFLD = FLDTAB(Z)
         IF FFLD.UTXT > 0 THEN
            UTXT$(FFLD.UTXT) = SPACE$(FFLD.FLDL \ 256)
            IF ((FFLD.CATR AND 17) > 0) THEN HTXT$(FFLD.UTXT) = UTXT$(FFLD.UTXT)
            LSET UTXT$(FFLD.UTXT) = DTXT$(Z)
         END IF
         Z = FLDCHN(Z).FWD
      WEND
      Y = FMTCHN(Y).FWD
   WEND
   GOTO PGMEND
PGMMSGS:
   CALL MsgGrpLOAD(PGRP$, X)
   IF OKAY THEN CALL FmtGrpLOAD(PGRP$, X)
   IF OKAY AND (OGRP$ <> "    ") THEN
      CALL MsgGrpFREE(OGRP$)
      CALL FmtGrpFREE(OGRP$)
   END IF
PGMEND:
   IF OKAY THEN
      ENV.PGMRTRN = ENV.PGMNAME
      ENV.PGMNAME = SYSVAR.PGMNAME
      ENV.PGRP = XGRP
      WIN = WINTAB(1): ENV.WINLVL = 1: ENV.WINHiLVL = 1
      CALL WinBDRY(0, 0)
   END IF
   ON LOCAL ERROR GOTO 0
   CLOSE
END SUB

REM $DYNAMIC
SUB PutMSG (MSGTXT$)
   MRESP = 0: MSG$ = SPACE$(255): LSET SYSVAR.MSGNAME = ""
   SLIN = CSRLIN: SPOS = POS(0)
   IF (LEN(MSGTXT$) <> 8) THEN LSET MSG$ = MSGTXT$: GOTO EXPVARS
   CALL MSGFind(MSGTXT$, Z)
   IF FOUND THEN GOTO BUILDMSG
   CALL MSGFind("XXXXM000", Z)
   IF FOUND THEN
      SYSVAR.MVAR = MSGTXT$
      GOTO BUILDMSG
   END IF
   LSET MSG$ = "Message " + RTRIM$(MSGTXT$) + " Not Found"
   MRESP = -1: GOTO MSGPUT
BUILDMSG:
   MRESP = (MID$(MSGDATA$(Z), 5, 1) <> " ")
   IF MRESP THEN RD$ = MID$(MSGDATA$(Z), 6, 1)
   ERRTone = VAL((MID$(MSGDATA$(Z), 7, 1)))
   LSET MSG$ = MID$(MSGDATA$(Z), 8, 255)
EXPVARS:
   CALL MSGExpand(MSG$)
MSGPUT:
   ML = LEN(RTRIM$(MSG$)): IF ML > 78 THEN ML = 78
   COLOR FG(1), BG(1)
   OFST = ((78 - ML) / 2)
   LOCATE 25, 1, 0
   IF OFST > 0 THEN PRINT TAB(OFST);
   PRINT LEFT$(MSG$, ML); TAB(79);
   IF ERRTone <> 0 THEN CALL ErrBEEP(ERRTone)
   IF ENV.SHOWMSGID AND SYSVAR.MSGNAME <> SPACE$(8) THEN
      COLOR FG(5), BG(5): LOCATE 25, 1, 0: PRINT SYSVAR.MSGNAME;
   END IF
   IF MRESP THEN
      CALL GetKEY: IF LEN(A$) = 1 THEN A$ = UCASE$(A$)
      IF (A$ = " ") OR (A$ = CHR$(13)) THEN A$ = RD$: A = ASC(A$)
      COLOR FG(1), BG(1): LOCATE 25, 1, 0: PRINT TAB(79);
   END IF
   LOCATE SLIN, SPOS, 0
END SUB

REM $STATIC
SUB ScrnCLR
    COLOR FG(1), BG(1): CLS : ENV.ScrnCLR = -1
    IF ENV.WINLVL > 0 THEN WINTAB(ENV.WINLVL) = WIN: ENV.WINLVL = 0
    X = ENV.WINHiLVL
    WHILE X > 0
       WIN = WINTAB(X)
       WIN.WFMT = 0: WIN.DFMT = 0: WIN.OFMT = 0
       WINTAB(X) = WIN
       X = X - 1
    WEND
    CLS
END SUB

SUB SDFOpen (OPT$)
    OKAY = 0
    LSET SYSVAR.FILENAME = CONFIG.SDF + "SFMTS.SDF"
    ON LOCAL ERROR GOTO NOSDF
CHKSDF:
    OPEN SYSVAR.FILENAME FOR INPUT AS #1
    CLOSE #1
    IF OPT$ = "NEW" THEN
       CALL PutMSG("XXXXM002")
       IF A$ <> SNGLKEY$(1) THEN GOTO SDFOpenEND
       KILL SYSVAR.FILENAME
       GOTO NEWSDF
    END IF
    GOTO OLDSDF
NOSDF:
    X = ERR: CLOSE
    IF OPT$ = "NEW" THEN RESUME NEWSDF
    CALL ERRMessage("XXXXM030", X, 0)
    IF A = 27 THEN RESUME SDFOpenEND
    RESUME CHKSDF
OLDSDF:
    ON LOCAL ERROR GOTO SDFOpenERR
    SELECT CASE OPT$
       CASE "READ": OPEN SYSVAR.FILENAME FOR BINARY ACCESS READ AS #1
       CASE "WRITE": OPEN SYSVAR.FILENAME FOR BINARY ACCESS READ WRITE AS #1
       CASE ELSE: GOTO SDFOpenEND
    END SELECT
    GET #1, , SDFHdr
    LSET SYSVAR.MVAR = "SDF"
    IF SDFHdr.FTYPE <> "SDF" THEN
       CALL PutMSG("XXXXM033")
       GOTO SDFOpenEND
    END IF
    IF SDFHdr.VER <> CHR$(0) THEN
       CALL PutMSG("XXXXM036")
       IF A$ <> SNGLKEY$(1) THEN GOTO SDFOpenEND
    END IF
    OKAY = -1
    GOTO SDFOpenEND
NEWSDF:
    ON LOCAL ERROR GOTO SDFOpenERR
    OPEN SYSVAR.FILENAME FOR BINARY ACCESS READ WRITE AS #1
    OKAY = -1
    GOTO SDFOpenEND
SDFOpenERR:
    CALL ERRMessage("XXXXM030", ERR, ERL)
    RESUME SDFOpenEND
SDFOpenEND:
    IF NOT OKAY THEN CLOSE  ELSE ENV.SDF = CONFIG.SDF
    ON LOCAL ERROR GOTO 0
END SUB

REM $DYNAMIC
SUB SetScrCOLOR
     XATR = SCREEN(WIN.CLIN, WIN.CCOL, 1)
5361 FGND = XATR MOD 16: BGND = INT((XATR MOD 128) / 16)
     BLINK = (XATR > 127)
     FGND = FGND - 16 * BLINK
     COLOR FGND, BGND
END SUB

REM $STATIC
FUNCTION SNX$ (A)
   SNX$ = RTRIM$(LTRIM$(STR$(ABS(A))))
END FUNCTION

REM $DYNAMIC
SUB TabINIT
    CALL DataINIT("TABLES"): IF NOT OKAY THEN EXIT SUB
    INPUT #5, TABMAX
    REDIM XTDF(TABMAX) AS TableFileDIR, TABLE(TABMAX) AS TablePARMS
    REDIM SNGLKEY$(0)
    FOR X = 1 TO TABMAX
        INPUT #5, TDFDir.NAME, TDFDir.ENTCNT, TDFDir.XL
        XTDF(X) = TDFDir
    NEXT X
    REDIM TDFIndex(TABMAX) AS TableFileDIR
    FOR X = 1 TO TABMAX: TDFIndex(X) = XTDF(X): NEXT X
    CALL TableLOAD("INITIAL", T, 0)
    IF NOT OKAY THEN EXIT SUB
    FOR X = 1 TO TABMAX
        IF (TDFIndex(X).NAME = XTDF(X).NAME) OR (TDFIndex(X).NAME = "") THEN
           TDFIndex(X).NAME = XTDF(X).NAME
           TDFIndex(X).XL = XTDF(X).XL
        END IF
    NEXT X

    ' Load ERRMSGS Table
    CALL TableLOAD("ERRMSGS", T, 0)
    EMCNT = TABLE(T).SIZE: REDIM ERRMSG$(EMCNT)
    X = TABLE(T).FT: Z = 0
    WHILE X > 0
       ERRMSG$(Z) = RTRIM$(TABDATA$(X))
       Z = Z + 1: X = TABDATACHN(X).FWD
    WEND
    CALL TableFREE("ERRMSGS")

    'Load RELRULES Table
    CALL TableLOAD("RELRULES", T, 0): TS = TABLE(T).SIZE
    REDIM RELRULE$(TS)
    X = TABLE(T).FT: Z = 0
    WHILE X > 0
       Z = VAL(MID$(TABDATA$(X), 1, 2))
       IF Z <= TS THEN
          RELRULE$(Z) = RTRIM$(MID$(TABDATA$(X), 3, 12))
       END IF
       X = TABDATACHN(X).FWD
    WEND
    CALL TableFREE("RELRULES")

    ' Load RELCODES Table
    CALL TableLOAD("RELCODES", T, 0): TS = TABLE(T).SIZE
    REDIM RELCODE$(TS)
    X = TABLE(T).FT: Z = 0
    WHILE X > 0
       Z = VAL(MID$(TABDATA$(X), 1, 2))
       IF Z <= TS THEN
          RELCODE$(Z) = RTRIM$(MID$(TABDATA$(X), 1, 17))
       END IF
       X = TABDATACHN(X).FWD
    WEND
    CALL TableFREE("RELCODES")

    ' Load GENDER Table
    CALL TableLOAD("GENDER", T, 0): TS = TABLE(T).SIZE
    REDIM FGENDR$(TS)
    X = TABLE(T).FT: Z = 0
    WHILE X > 0
      Z = VAL(MID$(TABDATA$(X), 1, 1))
      IF Z <= TS THEN
         FGENDR$(Z) = MID$(TABDATA$(X), 2, 1)
      END IF
      X = TABDATACHN(X).FWD
    WEND
    CALL TableFREE("GENDER")

    'Load REFERENC Table
    CALL TableLOAD("REFERENC", T, 0): TS = TABLE(T).SIZE
    REDIM RXIMP(TS), RXSYM$(TS)
    X = TABLE(T).FT: Z = 0
    WHILE X > 0
      Z = VAL(MID$(TABDATA$(X), 1, 2))
      IF Z <= TS THEN
         RXIMP(Z) = VAL(MID$(TABDATA$(X), 3, 2))
      END IF
      X = TABDATACHN(X).FWD
    WEND
    CALL TableFREE("REFERENC")

    'Load UCTRAN Table
    CALL TableLOAD("UCTRAN", T, 0): TS = TABLE(T).SIZE
    UCT1$ = STRING$(255, 0)
    REDIM UCTRAN$(TS)
    X = TABLE(T).FT: Y = 0: Z = 0
    WHILE X > 0
      IF Y < TS THEN
         Y = Y + 1
         Z = ASC(MID$(TABDATA$(X), 1, 1))
         MID$(UCT1$, Z, 1) = CHR$(Y)
         UCTRAN$(Y) = RTRIM$(MID$(TABDATA$(X), 2, 3))
      END IF
      X = TABDATACHN(X).FWD
    WEND
    CALL TableFREE("UCTRAN")

    ' Load SOUNDEX Table
    CALL TableLOAD("SOUNDEX", T, 0)
    SNDXTB$ = STRING$(255, 255)
    SXTB$ = "01230120022455012623010202"
    X$ = " "
    FOR X = 1 TO 26
        LSET X$ = MID$(SXTB$, X, 1)
        MID$(SNDXTB$, 64 + X, 1) = X$
        MID$(SNDXTB$, 96 + X, 1) = X$
    NEXT X
    X = TABLE(T).FT
    WHILE X > 0
       IF LEN(TABDATA$(X)) = 2 THEN
          Z1 = ASC(MID$(TABDATA$(X), 1, 1))
          MID$(SNDXTB$, Z1, 1) = MID$(TABDATA$(X), 2, 1)
       END IF
       X = TABDATACHN(X).FWD
    WEND
    CALL TableFREE("SOUNDEX")

250 ' Build SNGLKEY$() AND SKEG() - the Single Key Edit Group Table
    CALL TableLOAD("SINGLKEY", T, 0)
    Z = TABLE(T).SIZE
    REDIM SNGLKEY$(Z)
    X = TABLE(T).FT: SNGLKEY$(0) = CHR$(Z)
    WHILE X > 0
       Y = VAL(MID$(TABDATA$(X), 1, 2))
       SNGLKEY$(Y) = MID$(TABDATA$(X), 3, 1)
       X = TABDATACHN(X).FWD
    WEND
    CALL TableFREE("SINGLKEY")
    CALL DataINIT("SKEGTAB")
    IF OKAY THEN
       INPUT #5, Z
       REDIM SKEG(Z)
       FOR X = 0 TO Z: INPUT #5, SKEG(X): NEXT X
    END IF

END SUB

REM $STATIC
SUB TableFREE (TNAME$)
    TNUM = TABMAX: OKAY = -1
    IF TNAME$ = "ALL" THEN GOTO TABFREE
    TN$ = SPACE$(8): LSET TN$ = TNAME$
    FOUND = 0
    WHILE (TNUM > 0) AND (NOT FOUND)
       FOUND = (TABLE(TNUM).TABNAME = TN$)
       IF NOT FOUND THEN TNUM = TNUM - 1
    WEND
TABFREE:
    IF TNUM < 1 THEN EXIT SUB
    IF (TABLE(TNUM).OPEN) AND (TDFIndex(TNUM).FIRST > 0) THEN
       X = TABDATAFREE
       Y = TABLE(TNUM).LT: TABLE(TNUM).LT = 0
       IF X > 0 THEN TABDATACHN(X).BWD = Y
       IF Y > 0 THEN TABDATACHN(Y).FWD = X
       WHILE Y > 0
          TABDATA$(Y) = ""
          Y = TABDATACHN(Y).BWD
       WEND
       X = TABLE(TNUM).FT: TABLE(TNUM).FT = 0
       IF X > 0 THEN
          TABDATACHN(X).BWD = 0
          TABDATAFREE = X
       END IF
       TABLE(TNUM).OPEN = 0
    END IF
    IF TNAME$ = "ALL" THEN TNUM = TNUM - 1: GOTO TABFREE
END SUB

SUB TableKEY (OPT$, TP AS TablePARMS, TDATA$())
    SELECT CASE OPT$
      CASE "HILITE": MC = 1: C1$ = " ": C2$ = " ": KC = 5
      CASE "MARK": MC = 6: C1$ = CHR$(16): C2$ = CHR$(17): KC = TP.KCOLOR
      CASE "UNMARK": MC = 1: C1$ = " ": C2$ = " ": KC = TP.KCOLOR
    END SELECT
    COLOR FG(MC), BG(MC)
    LOCATE TP.CL + WIN.ULR, WIN.ULC + 1, 0: PRINT C1$;
    LOCATE TP.CL + WIN.ULR, WIN.LRC - 1, 0: PRINT C2$;
    IF TP.KEYFLD > 0 THEN
       COLOR FG(KC), BG(KC)
       LOCATE TP.CL + WIN.ULR, TP.KC + WIN.ULC, 0
       PRINT MID$(TDATA$(TP.CT), TP.KO, TP.KL);
       PL = POS(0) - TP.KC - WIN.ULC
       IF PL < TP.KL THEN PRINT SPACE$(TP.KL - PL);
    END IF
END SUB

SUB TableLOAD (TNAME$, TNUM AS INTEGER, XL AS INTEGER)
    ON LOCAL ERROR GOTO TLERR
    TL = XL
    TN$ = SPACE$(8): LSET TN$ = TNAME$
    IF (TNAME$ = "ALL") OR (TNAME$ = "INITIAL") THEN GOTO TabINIT
    IF (CONFIG.TDF = ENV.TDF) THEN GOTO TABLKUP
    TDFChange = -1
TabINIT:
    CALL TDFOpen("READ"): IF NOT OKAY THEN GOTO TLEND
    FILEOPEN = -1
    TDFMAX = TDFHdr.TABCNT
    IF TNAME$ = "ALL" THEN TABDATAMAX = TDFHdr.ENTCNT ELSE TABDATAMAX = 0
    REDIM TABDATA$(TABDATAMAX), TABDATACHN(TABDATAMAX) AS ChainPTRS
    CALL ChnINIT(TABDATACHN(), 1, TABDATAMAX)
    TABDATAFREE = -(TABDATAMAX > 0)
    SEEK #1, LEN(TDFHdr) + 1
    FOR TN = 1 TO TABMAX
       TDFIndex(TN).CHG = 0
       TDFIndex(TN).ENTCNT = 0: TDFIndex(TN).FIRST = 0
    NEXT TN
    FOR TN = 1 TO TDFMAX
       GET #1, , TDFDir
       XN = 0: FOUND = 0
       WHILE (XN < TABMAX) AND (NOT FOUND)
          XN = XN + 1
          FOUND = (TDFDir.NAME = TDFIndex(XN).NAME)
       WEND
       IF FOUND THEN
          XL = TDFIndex(XN).XL
          TDFIndex(XN) = TDFDir
          TDFIndex(XN).XL = XL
       END IF
    NEXT TN
    FOR TN = 1 TO TABMAX
        TABLE(TN).TABNAME = TDFIndex(TN).NAME
        TABLE(TN).OPEN = 0
        TABLE(TN).SIZE = TDFIndex(TN).ENTCNT
        TABLE(TN).XL = TDFIndex(TN).XL
        TABLE(TN).KO = TDFIndex(TN).KO
        TABLE(TN).KL = TDFIndex(TN).KL
        TABLE(TN).FT = 0: TABLE(TN).LT = 0
    NEXT TN
    OKAY = -1
    ENV.TDF = CONFIG.TDF
    IF TNAME$ = "ALL" THEN GOTO TABLKUP
CHGGRPS:
    CN = 0
CHGNEXT:
    CN = CN + 1
    SELECT CASE CN
       CASE 1: LSET TN$ = "SINGLKEY": TL = 3: GOTO TABLKUP
       CASE 2: LSET TN$ = "RPTOPTS": TL = 45: GOTO TABLKUP
    END SELECT
    IF TNAME$ = "INITIAL" THEN GOTO TLEND
    TL = XL: TDFChange = 0
TABLKUP:
    TN = 1: OKAY = 0
    IF TNAME$ = "ALL" THEN GOTO TABLOAD
    FOUND = 0: TNUM = 0
    WHILE (TN < TABMAX + 1) AND (NOT FOUND)
       FOUND = (TDFIndex(TN).NAME = TN$)
       IF NOT FOUND THEN TN = TN + 1
    WEND
    IF NOT FOUND THEN
       LSET SYSVAR.MVAR = TN$
       CALL PutMSG("XXXXM013")
       EXIT SUB
    END IF
    IF TNAME$ <> "INITIAL" THEN TNUM = TN
TABLOAD:
    IF TN > TABMAX THEN GOTO TLEND
    IF TL > 0 THEN ML = TL ELSE ML = TABLE(TN).XL
    IF (TABLE(TN).OPEN) THEN
       IF ((NOT (ML > TABLE(TN).ML)) OR (TDFIndex(TN).FIRST = 0)) THEN
          OKAY = -1: GOTO TABNEXT
       END IF
    END IF:
    IF NOT FILEOPEN THEN
       CALL TDFOpen("READ")
       IF NOT OKAY THEN GOTO TLEND
       FILEOPEN = -1
    END IF
    IF TDFIndex(TN).FIRST = 0 THEN
       IF (TNAME$ <> "ALL") AND (TNAME$ <> "UCTRAN") AND (TNAME$ <> "SOUNDEX") THEN
          SYSVAR.MVAR = TABLE(TN).TABNAME
          CALL PutMSG("XXXXM014")
       END IF
       GOTO TABNEXT
    END IF
    L$ = " "
    SEEK #1, TDFIndex(TN).FIRST
    X = TABLE(TN).SIZE: X1 = 0
    WHILE (X > 0)
       IF TABDATAFREE = 0 THEN
          TABDATAFREE = TABDATAMAX + 1
          TABDATAMAX = TABDATAMAX + X
          REDIM PRESERVE TABDATA$(TABDATAMAX), TABDATACHN(TABDATAMAX) AS ChainPTRS
          CALL ChnINIT(TABDATACHN(), TABDATAFREE, TABDATAMAX)
          IF X1 > 0 THEN TABDATACHN(X1).FWD = TABDATAFREE
       END IF
       IF X1 = 0 THEN
          TABLE(TN).FT = TABDATAFREE
          TABDATACHN(TABDATAFREE).BWD = -TN
          ELSE
          TABDATACHN(TABDATAFREE).BWD = X1
       END IF
       X1 = TABDATAFREE: TABDATAFREE = TABDATACHN(TABDATAFREE).FWD
       GET #1, , L$
       ENTRY$ = SPACE$(ASC(L$))
       GET #1, , ENTRY$
       TABDATA$(X1) = LEFT$(ENTRY$, ML)
       X = X - 1
    WEND
    TABLE(TN).LT = X1
    IF TABDATAFREE > 0 THEN TABDATACHN(TABDATAFREE).BWD = 0
    IF X1 > 0 THEN TABDATACHN(X1).FWD = 0
    TABLE(TN).ML = ML
    TABLE(TN).OPEN = -1
    OKAY = -1
    IF TN$ = "RPTOPTS " THEN ENV.OPTTAB = TN
TABNEXT:
    IF TNAME$ = "ALL" THEN TN = TN + 1: GOTO TABLOAD
    IF TNAME$ = "INITIAL" THEN GOTO CHGNEXT
    IF TDFChange THEN GOTO CHGGRPS
    GOTO TLEND
TLERR:
    SYSVAR.MVAR = TN$
    CALL PutMSG("XXXXM079")
    OKAY = 0: RESUME TLEND
TLEND:
    CLOSE
    IF (NOT OKAY) AND (CONFIG.TDF <> ENV.TDF) AND (A <> 27) THEN
       CONFIG.TDF = ENV.TDF: GOTO TABLKUP
    END IF
    ON LOCAL ERROR GOTO 0
END SUB

REM $DYNAMIC
SUB TableOPEN (TP AS TablePARMS)
    IF TP.FMTNUM = 0 THEN
       CALL FmtFIND(TP.FMTNAME)
       TP.FMTNUM = CURFMT
       X = 0: Y = FMT.BGNFLD: FOUND = 0: TP.KEYFLD = 0
       WHILE (Y > 0)
          FFLD = FLDTAB(Y)
          IF NOT FOUND THEN
             FOUND = (TP.KEYNAME = FFLD.NAME)
             IF FOUND THEN
                TP.KEYFLD = Y
                TP.KO = X + 1
                TP.KL = (FFLD.FLDL AND 255)
             END IF
          END IF
          X = (X + (FFLD.FLDL \ 256))
          Y = FLDCHN(Y).FWD
       WEND
       IF TP.XL = 0 THEN TP.XL = X
       TP.CL = 0
       ELSE : FMT = FMTTAB(TP.FMTNUM)
    END IF
    TP.TL = (FLDTAB(FMT.BGNFLD).LLCC \ 256)
    TP.BL = WIN.LRR - WIN.ULR - 3
    IF (TP.BL - TP.TL) < 10 THEN TP.BL = TP.BL + 1
    IF TP.KEYFLD > 0 THEN
       TP.KC = (FLDTAB(TP.KEYFLD).LLCC AND 255)
       TP.KCOLOR = FLDTAB(TP.KEYFLD).CATR \ 256
    END IF
    IF TP.CL = 0 THEN TP.CL = TP.TL: TP.FS = TP.FT: TP.CT = TP.FS
END SUB

REM $STATIC
SUB TableSELECT (TP AS TablePARMS, TDATA$(), TCHN() AS ChainPTRS)
    CURFMT = TP.FMTNUM: FMT = FMTTAB(CURFMT)
    IF TP.CL = 0 THEN TP.CL = TP.TL: TP.CT = TP.FS
SHOWKEY:
    IF NLIN > 0 THEN
       CALL TableKEY("UNMARK", TP, TDATA$())
       TP.CL = NLIN: TP.CT = NTAB
    END IF: NLIN = 0
    IF TP.KEYFLD > 0 THEN
       CALL TableKEY("HILITE", TP, TDATA$())
       ELSE
       CALL TableKEY("MARK", TP, TDATA$())
    END IF
USERCTL:
    CALL GetKEY: IF LEN(A$) > 1 THEN GOTO FUNKEY
    IF (A = 27) OR (A = 13) THEN EXIT SUB
    CALL ErrBEEP(0): GOTO USERCTL
FUNKEY:
    IF A = 72 THEN                            ' UP
       NLIN = TP.CL - 1: NTAB = TCHN(TP.CT).BWD
       IF NLIN < TP.TL THEN NLIN = TP.TL
       IF NTAB < 1 THEN NTAB = TP.FS: CALL ErrBEEP(0): GOTO SHOWKEY
       IF (NLIN < TP.CL) THEN GOTO SHOWKEY
       TP.CT = NTAB: TP.FS = NTAB
       GOTO PAGEFILL
    END IF
    IF A = 80 THEN                            ' DOWN
       NLIN = TP.CL + 1: NTAB = TCHN(TP.CT).FWD
       IF NLIN > TP.LL THEN NLIN = TP.LL
       IF NTAB < 1 THEN NTAB = TP.LS: CALL ErrBEEP(0): GOTO SHOWKEY
       IF (NLIN > TP.CL) THEN GOTO SHOWKEY
       TP.CT = NTAB: TP.LS = NTAB
       TP.FS = TCHN(TP.FS).FWD: IF TP.FS < 1 THEN TP.FS = TP.LS
       GOTO PAGESHOW
    END IF
    IF A = 73 THEN                            ' PGUP
       IF (TP.FS = TP.FT) THEN CALL ErrBEEP(0): GOTO USERCTL
       IF (TP.LS = TP.CT) THEN TP.CT = TP.FS
       TP.LS = TP.CT
       X = TP.BL: Y = TP.LS
       WHILE (X > TP.TL - 1) AND (Y > 0)
          TP.FS = Y: X = X - 1: Y = TCHN(Y).BWD
       WEND
       TP.LL = TP.TL + TP.BL - X + (X < TP.TL) + (X > TP.TL)
       IF TP.CL = TP.BL THEN TP.CL = TP.TL: TP.CT = TP.FS
       IF TP.CL > TP.TL THEN TP.CL = TP.LL
       GOTO PAGESHOW
    END IF
    IF A = 81 THEN                            ' PGDN
       IF (TP.LS = TP.LT) THEN CALL ErrBEEP(0): GOTO USERCTL
       IF (TP.FS = TP.CT) THEN TP.CT = TP.LS
       TP.CL = TP.TL: TP.FS = TP.CT
       GOTO PAGEFILL
    END IF
    EXIT SUB
PAGEFILL:
    X = TP.CL: Y = TP.CT
    WHILE (X < TP.BL + 1) AND (Y > 0)
       TP.LS = Y: X = X + 1: Y = TCHN(Y).FWD
    WEND
    TP.LL = X - 1
PAGESHOW:
    CALL TableSHOW(TP, TDATA$(), TCHN())
    NLIN = 0
    GOTO SHOWKEY
END SUB

SUB TableSHOW (TP AS TablePARMS, TDATA$(), TCHN() AS ChainPTRS)
    ' At Entry: TP.TL, TP.FS, TP.CL must have been determined
    ' At End:   TP.LL, TP.LS, TP.CT will have been determined
    CURFMT = TP.FMTNUM: FMT = FMTTAB(CURFMT)
    X = TP.TL: Y = TP.FS
    WHILE (X < TP.BL + 1) AND (Y > 0)
        O = 1
        COLOR FG(1), BG(1): LOCATE X + WIN.ULR, 1 + WIN.ULC
        PRINT TAB(WIN.LRC);
        Z = FMT.BGNFLD
        WHILE Z > 0
            FL = FLDTAB(Z).FLDL \ 256
            DL = (FLDTAB(Z).FLDL AND 255)
            OD = FLDTAB(Z).DO
            FCOLOR = FLDTAB(Z).CATR \ 256
            IF FCOLOR > 0 THEN
               CC = (FLDTAB(Z).LLCC AND 255)
               LOCATE X + WIN.ULR, CC + WIN.ULC, 0
               COLOR FG(FCOLOR), BG(FCOLOR)
               PRINT MID$(TDATA$(Y), OD + O, DL);
               PL = POS(0) - CC - WIN.ULC
               IF PL < DL THEN PRINT SPACE$(DL - PL);
            END IF
            O = O + FL
            Z = FLDCHN(Z).FWD
        WEND
        IF X = TP.CL THEN TP.CT = Y
        TP.LS = Y: X = X + 1: Y = TCHN(Y).FWD
    WEND: TP.LL = X - 1
    COLOR FG(1), BG(1)
    WHILE X < TP.BL + 1
       LOCATE X + WIN.ULR, 1 + WIN.ULC, 0: PRINT TAB(WIN.LRC); : X = X + 1
    WEND
END SUB

SUB TableUPDT (OPT$, TP AS TablePARMS, TDATA$(), TCHN() AS ChainPTRS)
    CURFMT = TP.FMTNUM: FMT = FMTTAB(CURFMT)
    SELECT CASE OPT$
       CASE "ADD": GOSUB TableADD
       CASE "CHG": GOSUB TableCHG
       CASE "DEL": GOSUB TableDEL
       CASE "MOD": GOSUB TableMOD: GOSUB TableCHG: GOSUB TableMOD
       CASE "MOV": GOSUB TableMOV
       CASE "NEW": GOSUB TableADD
       CASE "REM": GOSUB TableDEL
    END SELECT
    CALL PutMSG("")
TUExit:
    EXIT SUB

TableADD:
    NT = TP.FF
    IF NT = 0 THEN
       LSET SYSVAR.MVAR = TP.TABNAME
       CALL PutMSG("XXXXM021")
       GOTO TADDEnd
       END IF
    TP.FF = TCHN(NT).FWD: IF TP.FF > 0 THEN TCHN(TP.FF).BWD = 0
    IF TP.FT = 0 THEN
       TCHN(NT).BWD = 0: TCHN(NT).FWD = 0
       TP.FT = NT: TP.FS = NT: TP.CT = NT: TP.LT = NT
       TP.CL = TP.TL
    ELSE
       TCHN(NT).BWD = TP.CT: TCHN(NT).FWD = TCHN(TP.CT).FWD
       IF TCHN(NT).FWD > 0 THEN TCHN(TCHN(NT).FWD).BWD = NT
       TCHN(TP.CT).FWD = NT
       IF TP.CL = TP.BL THEN TP.FS = TCHN(TP.FS).FWD:  ELSE TP.CL = TP.CL + 1
       IF TP.LT = TP.CT THEN TP.LT = NT
    END IF
    TP.CT = NT
    TDATA$(NT) = SPACE$(TP.XL)
    TP.SIZE = TP.SIZE + 1
    IF OPT$ = "NEW" THEN GOTO TADDEnd
    CALL TableSHOW(TP, TDATA$(), TCHN())
    GOSUB TableMOD: GOSUB TableCHG: GOSUB TableMOD
    IF A = 27 THEN GOSUB TableDEL
TADDEnd: RETURN

TableCHG:
    CALL PutMSG("XXXXM011")
    O = 1: X = FMT.BGNFLD
    WHILE X > 0
       FFLD = FLDTAB(X)
       CC = (FFLD.LLCC AND 255): Y = FFLD.UTXT
       FLDTAB(X).LLCC = TP.CL * 256 + CC
       L = FLDTAB(X).FLDL \ 256
       IF (Y > 0) THEN LSET UTXT$(Y) = MID$(TDATA$(TP.CT), O, L)
       O = O + L
       X = FLDCHN(X).FWD
    WEND
    CALL FmtUHOLD
    CALL TableKEY("MARK", TP, TDATA$())
    WIN.CLIN = 0
    CALL WinUPDATE
    CALL TableKEY("UNMARK", TP, TDATA$())
    IF A = 27 THEN CALL FmtHREST: CALL WinFORMAT(CURFMT)
    O = 1: W$ = SPACE$(TP.XL): LSET W$ = TDATA$(TP.CT)
    X = FMT.BGNFLD
    WHILE X > 0
       FFLD = FLDTAB(X): FLDTAB(X).DO = 0
       CC = (FFLD.LLCC AND 255): FC = FFLD.CATR \ 256
       FLDTAB(X).LLCC = TP.TL * 256 + CC
       Y = FFLD.UTXT: L = FFLD.FLDL \ 256
       IF (Y > 0) AND (FC > 0) THEN
          MID$(W$, O, L) = UTXT$(Y)
       ELSE
          MID$(W$, O, L) = MID$(TDATA$(TP.CT), O, L)
       END IF
       O = O + L
       X = FLDCHN(X).FWD
    WEND
    TDATA$(TP.CT) = RTRIM$(W$)
    CALL TableSHOW(TP, TDATA$(), TCHN())
TCHGEnd: RETURN

TableDEL:
    TF = TP.FF
    TP.FF = TP.CT
    BT = TCHN(TP.CT).BWD: FT = TCHN(TP.CT).FWD
    TCHN(TP.FF).FWD = TF: TCHN(TP.FF).BWD = 0
    IF TF > 0 THEN TCHN(TF).BWD = TP.FF
    IF BT > 0 THEN TCHN(BT).FWD = FT
    IF FT > 0 THEN TCHN(FT).BWD = BT
    IF TP.CL = TP.TL THEN
       TP.FS = FT: IF TP.FS < 1 THEN TP.FS = BT
    ELSE
       IF FT = 0 THEN TP.CL = TP.CL - 1
    END IF
    IF TP.FT = TP.CT THEN TP.FT = FT
    IF TP.LT = TP.CT THEN TP.LT = BT
    TP.SIZE = TP.SIZE - 1
    IF OPT$ <> "REM" THEN CALL TableSHOW(TP, TDATA$(), TCHN())
TDELEnd: RETURN

TableMOD:
    X = FMT.BGNFLD
    WHILE X > 0
        Y = FLDTAB(X).CATR \ 256: Z = (FLDTAB(X).CATR AND 255)
        IF ((Z AND 17) = 17) THEN Z = (Z AND 254) ELSE IF ((Z AND 16) = 16) THEN Z = Z OR 1
        FLDTAB(X).CATR = (Y * 256) + Z
        X = FLDCHN(X).FWD
    WEND
    RETURN

TableMOV:
    CALL PutMSG("XXXXM010")
TMGetKey:
    CALL TableKEY("MARK", TP, TDATA$())
    CALL GetKEY
    CALL TableKEY("UNMARK", TP, TDATA$())
    IF (A = 27) OR (A = 13) THEN GOTO TMOVEnd
    IF LEN(A$) < 2 THEN CALL ErrBEEP(0): GOTO TMGetKey
    IF A = 59 THEN GOTO TMOVEnd
    IF A = 72 THEN
       BT = TCHN(TP.CT).BWD: FT = TCHN(TP.CT).FWD
       IF BT < 1 THEN CALL ErrBEEP(0): GOTO TMGetKey
       BTB = TCHN(BT).BWD
       TCHN(TP.CT).BWD = BTB
       TCHN(BT).BWD = TP.CT
       IF BTB > 0 THEN TCHN(BTB).FWD = TP.CT
       TCHN(TP.CT).FWD = BT
       TCHN(BT).FWD = FT
       IF FT > 0 THEN TCHN(FT).BWD = BT
       TP.CL = TP.CL - 1
       IF TP.CL <= TP.TL THEN TP.FS = TP.CT: TP.CL = TP.TL
       IF TP.FT = BT THEN TP.FT = TP.CT
       IF TP.LT = TP.CT THEN TP.LT = BT
       CALL TableSHOW(TP, TDATA$(), TCHN())
       GOTO TMGetKey
    END IF
    IF A = 80 THEN
       FT = TCHN(TP.CT).FWD: BT = TCHN(TP.CT).BWD
       IF FT < 1 THEN CALL ErrBEEP(0): GOTO TMGetKey
       FTF = TCHN(FT).FWD
       TCHN(FT).FWD = TP.CT
       TCHN(TP.CT).FWD = FTF
       IF BT > 0 THEN TCHN(BT).FWD = FT
       TCHN(FT).BWD = BT
       TCHN(TP.CT).BWD = FT
       IF FTF > 0 THEN TCHN(FTF).BWD = TP.CT
       IF TP.CL = TP.TL THEN TP.FS = FT
       TP.CL = TP.CL + 1
       IF TP.CL > TP.BL THEN TP.CL = TP.BL: TP.FS = TCHN(TP.FS).FWD
       IF TP.LT = FT THEN TP.LT = TP.CT
       IF TP.FT = TP.CT THEN TP.FT = FT
       CALL TableSHOW(TP, TDATA$(), TCHN())
       GOTO TMGetKey
    END IF
    CALL ErrBEEP(0)
    GOTO TMGetKey
TMOVEnd: RETURN

END SUB

SUB TDFOpen (OPT$)
    OKAY = 0
    SYSVAR.FILENAME = CONFIG.TDF + "TABLE.TDF"
    ON LOCAL ERROR GOTO NOTDF
CHKTDF:
    OPEN SYSVAR.FILENAME FOR INPUT AS #1
    CLOSE #1
    IF OPT$ = "NEW" THEN
       CALL PutMSG("XXXXM002")
       IF A$ <> SNGLKEY$(1) THEN GOTO TDFOpenEND
       KILL SYSVAR.FILENAME
       GOTO NEWTDF
    END IF
    GOTO OLDTDF
NOTDF:
    X = ERR: CLOSE
    IF OPT$ = "NEW" THEN RESUME NEWTDF
    CALL ERRMessage("XXXXM030", X, 0)
    IF A = 27 THEN RESUME TDFOpenEND
    RESUME CHKTDF
OLDTDF:
    ON LOCAL ERROR GOTO TDFOpenERR
    SELECT CASE OPT$
       CASE "READ": OPEN SYSVAR.FILENAME FOR BINARY ACCESS READ AS #1
       CASE "WRITE": OPEN SYSVAR.FILENAME FOR BINARY ACCESS WRITE AS #1
       CASE ELSE: GOTO TDFOpenEND
    END SELECT
    GET #1, , TDFHdr
    IF TDFHdr.FTYPE <> "TDF" THEN
       CALL PutMSG("TABLM010")
       GOTO TDFOpenEND
    END IF
    IF TDFHdr.VER <> CHR$(0) THEN
       CALL PutMSG("TABLM011")
       IF A$ <> SNGLKEY$(1) THEN GOTO TDFOpenEND
    END IF
    OKAY = -1
    GOTO TDFOpenEND
NEWTDF:
    ON LOCAL ERROR GOTO TDFOpenERR
    OPEN SYSVAR.FILENAME FOR BINARY ACCESS READ WRITE AS #1
    OKAY = -1
    GOTO TDFOpenEND
TDFOpenERR:
    CALL ERRMessage("XXXXM030", ERR, ERL)
    RESUME TDFOpenEND
TDFOpenEND:
    IF NOT OKAY THEN CLOSE  ELSE ENV.TDF = CONFIG.TDF
    ON LOCAL ERROR GOTO 0
END SUB

REM $DYNAMIC
SUB WinBDRY (C AS INTEGER, WNUM AS INTEGER)
5100 ' DRAW WINDOW BOUNDARIES
     BC = C: IF BC < 0 THEN BC = 10 ELSE IF BC = 0 THEN BC = WIN.BDRYCOL
     IF BC = 0 THEN EXIT SUB
     W = WNUM: IF W = 0 THEN W = WIN.WNUM
     ULR = WINDOWS(W).ULR: ULC = WINDOWS(W).ULC
     LRR = WINDOWS(W).LRR: LRC = WINDOWS(W).LRC
     COLOR FG(BC), BG(BC)
     LOCATE ULR, ULC, 0: PRINT MID$(WB$, 1, 1);
     FOR I = ULC + 1 TO LRC - 1: PRINT MID$(WB$, 2, 1); : NEXT I
     PRINT MID$(WB$, 3, 1);
     FOR I = ULR + 1 TO LRR - 1
       LOCATE I, ULC: PRINT MID$(WB$, 4, 1);
       LOCATE , LRC: PRINT MID$(WB$, 5, 1);
       NEXT I
     LOCATE LRR, ULC, 0: PRINT MID$(WB$, 6, 1);
     FOR I = ULC + 1 TO LRC - 1: PRINT MID$(WB$, 7, 1); : NEXT I
     PRINT MID$(WB$, 8, 1);
END SUB

REM $STATIC
SUB WinCLOSE (OLVL, NLVL)
     LVL1 = OLVL: IF LVL1 = 0 THEN LVL1 = ENV.WINLVL
     LVL2 = NLVL: IF LVL2 = 0 THEN LVL2 = ENV.WINLVL - 1
     IF LVL1 = 0 THEN CALL ErrBEEP(0): EXIT SUB
     IF WINTAB(LVL1).WNUM = 0 THEN CALL ErrBEEP(0): EXIT SUB
     IF (LVL1 <> ENV.WINLVL) THEN
        WINTAB(ENV.WINLVL) = WIN
        WIN = WINTAB(LVL1)
     END IF
     W = WIN.WNUM: BC = WIN.BDRYCOL
     IF W <> ENV.WINMSG THEN CALL WinCLR
     WINTAB(LVL1).WNUM = 0
     IF LVL1 = ENV.WINHiLVL THEN
        WHILE (ENV.WINHiLVL > 0) AND (WINTAB(ENV.WINHiLVL).WNUM = 0)
           ENV.WINHiLVL = ENV.WINHiLVL - 1
        WEND
     END IF
     WIN = WINTAB(LVL2)
     IF W <> ENV.WINMSG THEN
        IF WIN.WNUM = 1 THEN
           CALL WinBDRY(0, 0)
           IF BC > 0 THEN CALL WinBDRY(-1, W)
        ELSE
           IF BC > 0 THEN CALL WinBDRY(-1, W)
           CALL WinBDRY(0, 0)
        END IF
     END IF
     ENV.WINLVL = LVL2
END SUB

REM $DYNAMIC
SUB WinCLR
5200 ' CLEAR WINDOW
     COLOR FG(WIN.BGCOLOR), BG(WIN.BGCOLOR)
     FOR I = WIN.ULR + 1 TO WIN.LRR - 1
         LOCATE I, WIN.ULC + 1, 0
         PRINT TAB(WIN.LRC);
         NEXT I
     WIN.WFMT = 0: WIN.DFMT = 0: WIN.OFMT = 0
     WIN.TFMT = 0: WIN.MFMT = 0
     WIN.CURFLD = 0: WIN.CLIN = 0: WIN.CCOL = 0
END SUB

SUB WinDisplayDATA (FMTNUM)
    IF FMTNUM > 0 THEN CURFMT = FMTNUM
    IF CURFMT = 0 THEN CURFMT = WIN.DFMT
    IF CURFMT = 0 THEN EXIT SUB
    FMT = FMTTAB(CURFMT)
    WIN.CURFLD = FMT.BGNFLD
    WHILE WIN.CURFLD > 0
       CALL GetFldPARMS
       IF FFLD.UTXT > 0 THEN
          IF (BCOL < WIN.LRC) AND (FLIN < WIN.LRR) THEN
             IF ECOL < WIN.LRC THEN FL = ECOL - BCOL + 1 ELSE FL = WIN.LRC - BCOL
             PRINT MID$(UTXT$(FFLD.UTXT), FFLD.DO + 1, FL);
          END IF
       END IF
       WIN.CURFLD = FLDCHN(WIN.CURFLD).FWD
    WEND
    IF ((FMT.TYPE AND 2) = 2) THEN WIN.DFMT = CURFMT
END SUB

SUB WinDisplayLABELS (FMTNUM)
    IF FMTNUM > 0 THEN CURFMT = FMTNUM
    IF CURFMT = 0 THEN CURFMT = WIN.WFMT
    IF CURFMT = 0 THEN EXIT SUB
    FMT = FMTTAB(CURFMT)
    WIN.CURFLD = FMT.BGNFLD
    WHILE WIN.CURFLD > 0
       CALL GetFldPARMS
       IF FFLD.UTXT = 0 THEN
          IF (BCOL < WIN.LRC) AND (FLIN < WIN.LRR) THEN
             IF ECOL < LRC THEN FL = ECOL - BCOL + 1 ELSE FL = WIN.LRC - BCOL
             PRINT LEFT$(DTXT$(WIN.CURFLD), FL)
          END IF
       END IF
       WIN.CURFLD = FLDCHN(WIN.CURFLD).FWD
    WEND
    IF ((FMT.TYPE AND 1) = 1) THEN WIN.WFMT = CURFMT
END SUB

REM $STATIC
SUB WinERASE (C AS INTEGER, WNUM AS INTEGER)
    W = WNUM: IF W = 0 THEN W = WIN.WNUM
    IF W = 0 THEN EXIT SUB
    BC = C: IF BC = 0 THEN BC = WINDOWS(W).BGCOLOR
    IF BC = 0 THEN EXIT SUB
    COLOR FG(BC), BG(BC)
    ULR = WINDOWS(W).ULR: ULC = WINDOWS(W).ULC
    LRR = WINDOWS(W).LRR: LRC = WINDOWS(W).LRC
    FOR X = ULR TO LRR
        LOCATE X, ULC, 0
        PRINT TAB(LRC + 1);
    NEXT X
END SUB

REM $DYNAMIC
SUB WinFFLD
5400 ' Build UTXT$ for current field on screen
     LOCATE FLIN, BCOL, 0
     DL = (FFLD.FLDL AND 255)
     FOR I = 1 TO DL
       MID$(UTXT$(FFLD.UTXT), FFLD.DO + I, 1) = CHR$(SCREEN(FLIN, BCOL + I - 1))
       NEXT I
END SUB

SUB WinFORMAT (FMTNUM)
5600 ' Display FORMATTED screen from DATA statements
    IF FMTNUM > 0 THEN CURFMT = FMTNUM
    IF CURFMT = 0 THEN EXIT SUB
    FMT = FMTTAB(CURFMT)
    WIN.CURFLD = FMT.BGNFLD
    WHILE WIN.CURFLD > 0
       CALL GetFldPARMS
       IF (BCOL < WIN.LRC) AND (FLIN < WIN.LRR) THEN
          IF ECOL < WIN.LRC THEN FL = ECOL - BCOL + 1 ELSE FL = WIN.LRC - BCOL
          IF FFLD.UTXT > 0 THEN
             PRINT MID$(UTXT$(FFLD.UTXT), FFLD.DO + 1, FL);
             ELSE
             PRINT LEFT$(DTXT$(WIN.CURFLD), FL);
          END IF
          EP = BCOL + FL
          IF POS(0) < EP THEN PRINT TAB(EP);
       END IF
       WIN.CURFLD = FLDCHN(WIN.CURFLD).FWD
    WEND
    IF ((FMT.TYPE AND 1) = 1) THEN WIN.WFMT = CURFMT
    IF ((FMT.TYPE AND 2) = 2) THEN WIN.DFMT = CURFMT
    IF ((FMT.TYPE AND 4) = 4) THEN WIN.OFMT = CURFMT
    IF ((FMT.TYPE AND 8) = 8) THEN WIN.MFMT = CURFMT
    IF ((FMT.TYPE AND 16) = 16) THEN WIN.TFMT = CURFMT
     ' LOCATE 25, 1, 0: PRINT "TMP:"; FRE(""); "STK:"; FRE(-2); " FAR:"; FRE(-1);
    ENV.ScrnCLR = 0
END SUB

REM $STATIC
SUB WinINIT (LOC$)
     ' SCREEN.MRG --- Subroutines for Formatted Screens
     OKAY = 0: WLOC$ = "    ": LSET WLOC$ = LOC$
     WNUM = 0: FOUND = 0
     WHILE (WNUM < WINMAX) AND (NOT FOUND)
        WNUM = WNUM + 1: FOUND = (WINDOWS(WNUM).LOC = WLOC$)
     WEND
     IF (WNUM < 0) OR (WNUM > WINMAX) THEN CALL ErrBEEP(0): EXIT SUB
     IF ENV.WINLVL > 0 THEN
        WINTAB(ENV.WINLVL) = WIN
     END IF
     IF ENV.WINHiLVL < WINLVLMAX THEN
        ENV.WINLVL = ENV.WINHiLVL + 1
        ENV.WINHiLVL = ENV.WINLVL
     END IF
     WIN.WNUM = WNUM
     WIN.ULR = WINDOWS(WNUM).ULR: WIN.ULC = WINDOWS(WNUM).ULC
     WIN.LRR = WINDOWS(WNUM).LRR: WIN.LRC = WINDOWS(WNUM).LRC
     WIN.BGCOLOR = WINDOWS(WNUM).BGCOLOR: WIN.BDRYCOL = WINDOWS(WNUM).BDRYCOL
     WINTAB(ENV.WINLVL) = WIN
     OKAY = -1
END SUB

REM $DYNAMIC
SUB WinOPEN (LOC$)
5000 ' SCREEN.MRG --- Subroutines for Formatted Screens
     OKAY = 0: WLOC$ = "    ": LSET WLOC$ = LOC$
     WNUM = 0: FOUND = 0
     WHILE (WNUM < WINMAX) AND (NOT FOUND)
        WNUM = WNUM + 1: FOUND = (WINDOWS(WNUM).LOC = WLOC$)
     WEND
     IF (WNUM < 0) OR (WNUM > WINMAX) THEN CALL ErrBEEP(0): EXIT SUB
     IF ENV.WINLVL > 0 THEN
        IF WNUM <> ENV.WINMSG THEN CALL WinBDRY(-1, 0)
        WINTAB(ENV.WINLVL) = WIN
     END IF
     IF ENV.WINHiLVL < WINLVLMAX THEN
        ENV.WINLVL = ENV.WINHiLVL + 1
        ENV.WINHiLVL = ENV.WINLVL
     END IF
     WIN.WNUM = WNUM
     WIN.ULR = WINDOWS(WNUM).ULR: WIN.ULC = WINDOWS(WNUM).ULC
     WIN.LRR = WINDOWS(WNUM).LRR: WIN.LRC = WINDOWS(WNUM).LRC
     WIN.BGCOLOR = WINDOWS(WNUM).BGCOLOR: WIN.BDRYCOL = WINDOWS(WNUM).BDRYCOL
     CALL WinBDRY(0, WNUM)
     CALL WinCLR
     WINTAB(ENV.WINLVL) = WIN
     OKAY = -1
END SUB

REM $STATIC
SUB WinPREP (WLVL)
    OKAY = (ENV.WINLVL = WLVL)
    IF OKAY THEN EXIT SUB
    IF (WLVL < 0) OR (WLVL > ENV.WINHiLVL) THEN CALL ErrBEEP(0): EXIT SUB
    IF WINTAB(WLVL).WNUM = 0 THEN CALL ErrBEEP(0): EXIT SUB
    IF ENV.WINLVL > 0 THEN WINTAB(ENV.WINLVL) = WIN
    W = WIN.WNUM: BC = WIN.BDRYCOL
    WIN = WINTAB(WLVL)
    ENV.WINLVL = WLVL
    OKAY = -1
END SUB

SUB WinSWITCH (WLVL)
    OKAY = (ENV.WINLVL = WLVL)
    IF OKAY THEN EXIT SUB
    IF (WLVL < 0) OR (WLVL > ENV.WINHiLVL) THEN CALL ErrBEEP(0): EXIT SUB
    IF WINTAB(WLVL).WNUM = 0 THEN CALL ErrBEEP(0): EXIT SUB
    IF ENV.WINLVL > 0 THEN WINTAB(ENV.WINLVL) = WIN
    W = WIN.WNUM: BC = WIN.BDRYCOL
    WIN = WINTAB(WLVL)
    IF WIN.WNUM = 1 THEN
       CALL WinBDRY(0, 0)
       IF BC > 0 THEN CALL WinBDRY(-1, W)
       ELSE
       IF BC > 0 THEN CALL WinBDRY(-1, W)
       CALL WinBDRY(0, 0)
    END IF
    ENV.WINLVL = WLVL
    OKAY = -1
END SUB

REM $DYNAMIC
SUB WinUPDATE
     ' Allow Modification of Updatable fields in Current Format
     CALL GetUFLD("THIS"): IF NOT FOUND THEN CALL GetUFLD("FIRST")
     IF NOT FOUND THEN CALL ErrBEEP(0): A = 27: A$ = CHR$(A): EXIT SUB
     WIN.CLIN = FLIN: WIN.CCOL = BCOL
     ENV.EDINSRT = 0: H$ = SPACE$(100)
CHKEDTM:
     IF ((FATR AND 32) = 0) THEN GOTO NEXTKEY
     DL = FFLD.FLDL AND 255
     X = FFLD.DO + 1: LSET H$ = DTXT$(WIN.CURFLD)
     WHILE X > 0: Z$ = MID$(H$, X, 1)
        IF Z$ <> "" THEN
           Z = ASC(Z$)
           IF (Z <> 32) AND ((Z < 48) OR (Z > 57)) THEN X = X + 1 ELSE X = 0
           IF X > DL THEN
              X = 0
              ELSE
              IF X - FFLD.DO > DL THEN
                 FFLD.DO = FFLD.DO + 1
                 ELSE
                 WIN.CCOL = WIN.CCOL - (X > 0)
              END IF
           END IF
           ELSE
           X = 0
        END IF
     WEND
NEXTKEY:
     LOCATE WIN.CLIN, WIN.CCOL, 1
     CALL SetScrCOLOR
     PRINT CHR$(SCREEN(WIN.CLIN, WIN.CCOL)); : LOCATE WIN.CLIN, WIN.CCOL
     CALL GetKEY: LOCATE WIN.CLIN, WIN.CCOL, 0
     IF WIN.CURFLD > 0 THEN FL = FFLD.FLDL \ 256: DL = (FFLD.FLDL AND 255)
     IF LEN(A$) = 2 THEN GOTO SPECIAL
STDKEY:
     IF A = 27 THEN                        ' Escape Key
        IF (WIN.CURFLD > 0) AND (FFLD.UTXT > 0) THEN
           IF UTXT$(FFLD.UTXT) <> HTXT$(FFLD.UTXT) THEN
              A = 18: GOTO SPECIAL
           END IF
        END IF
        GOTO ENDUPDT
     END IF
     IF A = 13 THEN                         ' Enter Key
        HLIN = WIN.CLIN
        WIN.CLIN = WIN.CLIN + 1: IF WIN.CLIN > WIN.LRR THEN WIN.CLIN = WIN.ULR + 1
        WIN.CCOL = WIN.ULC + 1
        CALL GetUFLD("THIS")
        IF (NOT FOUND) THEN CALL GetUFLD("NEXT")
        IF HLIN = FLIN THEN GOTO ENDUPDT
        WIN.CLIN = FLIN: WIN.CCOL = BCOL
        GOTO CHKEDTM
     END IF
     IF A = 8 THEN A = 75: GOTO SPECIAL     ' back space
     IF A = 9 THEN                          ' TAB Forward
        IF WIN.CURFLD = 0 THEN CALL GetUFLD("THIS")
        CALL GetUFLD("NEXT")
        WIN.CLIN = FLIN: WIN.CCOL = BCOL
        GOTO CHKEDTM
     END IF
     IF A = 18 THEN GOTO SPECIAL              ' CTRL+"R"
     IF A = 28 THEN A = 77: GOTO SPECIAL      ' cursor right (Tandy 2000)
     IF A = 29 THEN A = 75: GOTO SPECIAL      ' cursor left  (Tandy 2000)
     IF (WIN.CURFLD = 0) OR (NOT FOUND) THEN GOTO BadKEY
     IF ((FATR AND 1) = 0) THEN GOTO BadKEY
     IF ((FATR AND 2) = 2) AND (A <> 32 AND (A < 40 OR A > 58)) THEN GOTO BadKEY
     IF ((FATR AND 4) = 4) AND (A > 96 AND A < 123) THEN A$ = CHR$(A - 32)
     IF A < 32 THEN GOTO BadKEY
     X = FFLD.UTXT: XCOL = WIN.CCOL - BCOL + 1
     FL = FFLD.FLDL \ 256: DL = (FFLD.FLDL AND 255)
     IF ((FATR AND 32) = 32) THEN     ' Check for EDITMASK Character Loc
        Z$ = (MID$(DTXT$(WIN.CURFLD), FFLD.DO + XCOL, 1))
        IF Z$ = "" THEN Z = 32 ELSE Z = ASC(Z$)
        IF ((Z <> 32) AND ((Z < 48) OR (Z > 57))) THEN GOTO BadKEY
     END IF
     IF (FATR AND 32) = 0 THEN         ' EDIT UNMASKED Field
        IF ((FATR AND 10) > 0) THEN    '   IF Numeric OR Adjright
           IF (WIN.CCOL = ECOL) AND ((FATR AND 128) = 128) THEN
              RSET UTXT$(X) = (RIGHT$(UTXT$(X), DL - 1) + A$)
              ELSEIF (WIN.CCOL = BCOL) AND ((FATR AND 128) = 0) THEN
                 RSET UTXT$(X) = A$: WIN.CCOL = ECOL: FATR = FATR OR 128
              ELSE
              MID$(UTXT$(X), XCOL, 1) = A$
           END IF
           LOCATE FLIN, BCOL: PRINT LEFT$(UTXT$(X), DL);
           IF WIN.CCOL = ECOL THEN
              IF ((FATR AND 128) AND (ASC(UTXT$(X)) <> 32)) OR NOT ((FATR AND 128) = 128) THEN A = 9: GOTO STDKEY
              ELSE
              WIN.CCOL = WIN.CCOL + 1
           END IF
           GOTO NEXTKEY
        END IF
     END IF
     IF ENV.EDINSRT THEN
        ELTH = FL - FFLD.DO - XCOL + 1
        LSET H$ = A$ + RIGHT$(UTXT$(X), ELTH)
        MID$(UTXT$(X), FFLD.DO + XCOL, ELTH) = H$
        LOCATE FLIN, BCOL, 0: PRINT MID$(UTXT$(X), FFLD.DO + 1, DL);
     ELSE
        PRINT A$;
        MID$(UTXT$(X), FFLD.DO + XCOL, 1) = A$
     END IF
     GOSUB CursRIGHT
     IF A = 9 THEN GOTO STDKEY
     GOTO NEXTKEY

CursRIGHT:
     A = 0: WIN.CCOL = WIN.CCOL + 1
     IF WIN.CURFLD = 0 THEN GOTO CRReturn
     XCOL = XCOL + 1
     IF (FFLD.DO + XCOL) > FL THEN
        IF FFLD.DO > 0 THEN CALL ErrBEEP(0): WIN.CCOL = ECOL:  ELSE A = 9
        GOTO CRReturn
     END IF
     IF WIN.CCOL > ECOL THEN
        FFLD.DO = FFLD.DO + 1
        FLDTAB(WIN.CURFLD).DO = FFLD.DO
        LOCATE FLIN, BCOL, 0: PRINT MID$(UTXT$(X), FFLD.DO + 1, DL);
        WIN.CCOL = ECOL
     END IF
     IF ((FATR AND 32) = 32) THEN     ' Skip EDITMASK Characters
        Z$ = (MID$(DTXT$(WIN.CURFLD), FFLD.DO + XCOL, 1))
        IF Z$ <> "" THEN
           Z = ASC(Z$)
           IF ((Z <> 32) AND ((Z < 48) OR (Z > 57))) THEN GOTO CursRIGHT
        END IF
     END IF
CRReturn:
     RETURN

CursLEFT:
     WIN.CCOL = WIN.CCOL - 1
     IF WIN.CURFLD = 0 THEN GOTO CLReturn
     XCOL = XCOL - 1
     IF XCOL < 1 THEN
        IF FFLD.DO > 0 THEN
           FFLD.DO = FFLD.DO - 1
           FLDTAB(WIN.CURFLD).DO = FFLD.DO
           LOCATE FLIN, BCOL, 0: PRINT MID$(UTXT$(X), FFLD.DO + 1, DL);
           XCOL = 1: WIN.CCOL = BCOL
        ELSE
           GOTO CLReturn
        END IF
     END IF
     IF ((FATR AND 32) = 32) THEN     ' Skip EDITMASK Characters
        Z$ = (MID$(DTXT$(WIN.CURFLD), FFLD.DO + XCOL, 1))
        IF Z$ <> "" THEN
           Z = ASC(Z$)
           IF ((Z <> 32) AND ((Z < 48) OR (Z > 57))) THEN GOTO CursLEFT
        END IF
     END IF
CLReturn:
     RETURN

SPECIAL: ' Special Function KEYs
     IF (A > 58) AND (A < 69) THEN GOTO ENDUPDT   ' F1-F10
     IF (A > 103) AND (A < 114) THEN GOTO ENDUPDT ' ALT+F1-F10
     IF (A > 93) AND (A < 104) THEN GOTO ENDUPDT  ' CTRL+F1-F10
     IF (A = 73) OR (A = 81) THEN GOTO ENDUPDT    ' PGUP, PGDN
     IF (A = 118) OR (A = 132) THEN GOTO ENDUPDT  ' ^PGUP, ^PGDN
     IF A = 15 THEN                          ' Shift+TAB = TAB Bwd
        CALL GetUFLD("THIS")
        IF FOUND THEN CALL GetUFLD("PREV")
        IF WIN.CURFLD = 0 THEN CALL GetUFLD("LAST")
        WIN.CLIN = FLIN: WIN.CCOL = BCOL
        GOTO CHKEDTM
     END IF
     IF A = 71 THEN                         ' Home key
        IF (WIN.CURFLD = 0) OR ((WIN.CCOL = BCOL) AND (FFLD.DO = 0)) THEN
           CALL GetUFLD("FIRST")
           ELSE
           IF WIN.CCOL = BCOL THEN
              FFLD.DO = 0: FLDTAB(WIN.CURFLD).DO = 0
              LOCATE FLIN, BCOL, 0: PRINT LEFT$(UTXT$(X), DL);
           END IF
        END IF
        WIN.CLIN = FLIN: WIN.CCOL = BCOL
        GOTO CHKEDTM
     END IF
     IF A = 72 THEN                         ' Move Cursor Up
        WIN.CLIN = WIN.CLIN - 1
        IF WIN.CLIN < WIN.ULR + 1 THEN WIN.CLIN = WIN.LRR - 1
        CALL GetUFLD("THIS")
        IF NOT FOUND THEN WIN.CURFLD = 0
        GOTO NEXTKEY
     END IF
     IF WIN.CURFLD > 0 THEN
        X = FFLD.UTXT: XCOL = WIN.CCOL - BCOL + 1
        FL = FFLD.FLDL \ 256: DL = (FFLD.FLDL AND 255)
     END IF
     IF A = 77 THEN                         ' Move Cursor Right
        GOSUB CursRIGHT
        IF WIN.CCOL > (WIN.LRC - 1) THEN
           WIN.CCOL = WIN.ULC + 1
           WIN.CLIN = WIN.CLIN + 1
           IF WIN.CLIN > (WIN.LRR - 1) THEN WIN.CLIN = WIN.ULR + 1
        END IF
        CALL GetUFLD("THIS")
        IF NOT FOUND THEN WIN.CURFLD = 0
        GOTO NEXTKEY
     END IF
     IF A = 75 THEN                         ' Move Cursor Left
        GOSUB CursLEFT
        IF WIN.CCOL < (WIN.ULC + 1) THEN
           WIN.CCOL = WIN.LRC - 1
           WIN.CLIN = WIN.CLIN - 1
           IF WIN.CLIN < (WIN.ULR + 1) THEN WIN.CLIN = WIN.LRR - 1
        END IF
        CALL GetUFLD("THIS")
        IF NOT FOUND THEN WIN.CURFLD = 0
        GOTO NEXTKEY
     END IF
     IF A = 79 THEN                         ' END Key
        IF (WIN.CURFLD = 0) OR ((WIN.CCOL = ECOL) AND (FFLD.DO = FL - DL)) THEN
           IF (WIN.CURFLD > 0) AND (FFLD.DO > 0) THEN
              FLDTAB(WIN.CURFLD).DO = 0
              LOCATE FLIN, BCOL, 0: PRINT LEFT$(UTXT$(X), DL);
           END IF
           CALL GetUFLD("LAST")
           WIN.CLIN = FLIN: WIN.CCOL = BCOL
           ELSE
           XCOL = LEN(RTRIM$(UTXT$(X)))
           IF XCOL < FL THEN XCOL = XCOL + 1
           IF (XCOL - FFLD.DO) <= DL THEN
              XDO = FFLD.DO
              ELSE
              IF (FL - XCOL) < DL THEN
                 XDO = FL - DL
                 ELSE
                 IF XCOL <= DL THEN
                    XDO = 0
                    ELSE
                    XDO = XCOL - DL
                 END IF
              END IF
           END IF
           XCOL = XCOL - XDO - 1 + BCOL
           IF (XCOL = WIN.CCOL) AND (XDO = FFLD.DO) THEN
              XCOL = ECOL: XDO = FL - DL
           END IF
           WIN.CCOL = XCOL: FFLD.DO = XDO: FLDTAB(WIN.CURFLD).DO = XDO
           LOCATE FLIN, BCOL, 0: PRINT MID$(UTXT$(X), FFLD.DO + 1, DL);
        END IF
        GOTO CHKEDTM
     END IF
     IF A = 80 THEN                         ' Move Cursor Down
        WIN.CLIN = WIN.CLIN + 1
        IF WIN.CLIN > WIN.LRR - 1 THEN WIN.CLIN = WIN.ULR + 1
        CALL GetUFLD("THIS")
        IF NOT FOUND THEN WIN.CURFLD = 0
        GOTO NEXTKEY
     END IF
     IF (WIN.CURFLD = 0) OR ((FATR AND 1) = 0) THEN GOTO BadKEY
     ELTH = FL - FFLD.DO - XCOL + 1
     IF A = 18 THEN                         ' CTRL+R (Restore HTXT$()
        LSET UTXT$(X) = HTXT$(X)
        LOCATE FLIN, BCOL, 0: PRINT MID$(UTXT$(X), FFLD.DO + 1, DL);
        GOTO NEXTKEY
     END IF
     IF A = 82 THEN                         ' Insert KEY
        ENV.EDINSRT = NOT ENV.EDINSRT
        COLOR FG(1), BG(1): LOCATE 25, 79, 0
        IF ENV.EDINSRT THEN PRINT "^"; :  ELSE PRINT " ";
        GOTO NEXTKEY
     END IF
     IF A = 83 THEN                         ' Delete KEY
        MID$(UTXT$(X), FFLD.DO + XCOL, ELTH - 1) = RIGHT$(UTXT$(X), ELTH - 1)
        MID$(UTXT$(X), FL, 1) = " "
        LOCATE FLIN, BCOL, 0: PRINT MID$(UTXT$(X), FFLD.DO + 1, DL);
        GOTO NEXTKEY
     END IF
     IF A = 117 THEN                ' CTRL+END = erase to end of field
        MID$(UTXT$(X), FFLD.DO + XCOL, ELTH) = SPACE$(ELTH)
        LOCATE FLIN, BCOL, 0: PRINT MID$(UTXT$(X), FFLD.DO + 1, DL);
        GOTO NEXTKEY
     END IF
BadKEY:
     CALL ErrBEEP(0): GOTO NEXTKEY
ENDUPDT:
     COLOR FG(1), BG(1): LOCATE 25, 79, 0: PRINT " ";
END SUB

